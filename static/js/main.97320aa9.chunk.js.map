{"version":3,"sources":["PathfindingVisualizer/Components/Node/Node.jsx","PathfindingVisualizer/Components/Buttons/DropdownMenu/DropdownMenu.jsx","PathfindingVisualizer/Components/Navigation/NavigationBar/NavigationBar.jsx","PathfindingVisualizer/Images/paintbrushes.svg","PathfindingVisualizer/Components/Hints/Hint.jsx","PathfindingVisualizer/Components/Buttons/DrawToggle/DrawToggle.jsx","PathfindingVisualizer/Images/weight-plates.svg","PathfindingVisualizer/Components/Buttons/Slider/Slider.js","PathfindingVisualizer/Components/AlgorithmTitle/AlgorithmTitle.jsx","PathfindingVisualizer/Components/Credits/Credits.jsx","PathfindingVisualizer/Components/Navigation/NavigationSection.jsx","PathfindingVisualizer/Data Structures/MinHeap.js","PathfindingVisualizer/Search Algorithms/SearchHelperFunctions.js","PathfindingVisualizer/Search Algorithms/Dijkstra.js","PathfindingVisualizer/Data Structures/Queue.js","PathfindingVisualizer/Search Algorithms/BreadthFirstSearch.js","PathfindingVisualizer/Search Algorithms/DepthFirstSearch.js","PathfindingVisualizer/Search Algorithms/AStar.js","PathfindingVisualizer/Functions/HelperFunctions.js","PathfindingVisualizer/Functions/GridFunctions.js","PathfindingVisualizer/PathfindingVisualizer.jsx","PathfindingVisualizer/Functions/ScreenFunctions.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","setState","isWall","handleOnMouseDown","row","col","handleOnMouseUp","handleOnMouseEnter","nextProps","nextState","isVisited","isPath","isStart","isTargetReached","isWeight","isTarget","direction","nodeType","onDragStart","e","preventDefault","className","onMouseDown","bind","onMouseUp","onMouseEnter","id","Component","DropdownMenu","useState","dropdownIsVisible","setDropdownIsVisible","title","onClick","children","map","child","index","NavigationBar","Hint","message","WALLS","WEIGHTS","Toggle","selected","setSelected","isHintDisplayed","setIsHintDisplayed","setDrawMode","toggleHint","src","brushesImg","width","height","onMouseLeave","Slider","value","setValue","weightImg","type","min","max","onChange","target","valueAsNumber","AlgorithmTitle","algorithm","infoIsDisplayed","setInfoIsDisplayed","dijkstraInfo","concat","bfsInfo","dfsInfo","aStarInfo","getInfo","Credits","href","NavigationSection","MinHeap","heap","node","push","currIndex","length","parentIndex","Math","floor","distance","head","tail","splice","leftChildIndex","rightChildIndex","minChild","minIndex","getNeighbors","numRows","numCols","grid","neighbors","isSafe","dijkstra","startNode","targetNode","weightValue","priorityQueue","visitedNodesInOrder","shortestPathReversed","insert","isEmpty","pop","pathNode","previousNode","neighbor","weight","Queue","queue","DoublyLinkedList","ListNode","popHead","getData","listNode","setNext","getNext","data","next","breadthFirstSearch","q","enqueue","dequeue","depthFirstSearch","pathReversed","dfs","aStar","f","abs","h","g","pathToLines","lines","directions","i","prevNode","currNode","dRow","dCol","line","NodeObj","Infinity","createInitialGrid","r","c","startNodeRow","startNodeCol","targetNodeRow","targetNodeCol","clearWeights","copyGrid","clearPath","resetNodes","clearWalls","gridCopy","rowCopy","Object","assign","document","getElementById","NUM_ROWS","window","innerHeight","NUM_COLS","body","scrollWidth","documentElement","offsetWidth","clientWidth","INITIAL_TARGET_ROW","INITIAL_TARGET_COL","ALGORITHM","DRAW_MODE","PathfindingVisualizer","setAlgorithmDijkstra","setAlgorithmBFS","setAlgorithmDFS","setAlgorithmAStar","visualizeAlgorithm","visualize","mode","drawMode","setWeightValue","launchPadRow","launchPadCol","mouseDown","isMovingStart","isMovingTarget","isMovingLaunchPad","onmouseup","onmouseleave","setUp","displayGrid","visualizeDijkstra","visualizeBreadthFirstSearch","visualizeDepthFirstSearch","visualizeAStar","animateSearch","setTimeout","animatePath","element","classList","remove","add","moveRocketShip","node_","prevTarget","redrawPath","prevLaunchPad","rowIndex","nodeIndex","draggable","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.97320aa9.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  toggleWall() {\n    this.setState({ isWall: !this.props.isWall });\n  }\n\n  handleOnMouseDown() {\n    this.props.handleOnMouseDown(this.props.row, this.props.col);\n  }\n\n  handleOnMouseUp() {\n    this.props.handleOnMouseUp();\n  }\n\n  handleOnMouseEnter() {\n    this.props.handleOnMouseEnter(this.props.row, this.props.col);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (\n      nextProps.isWall !== this.props.isWall ||\n      nextProps.isVisited !== this.props.isVisited ||\n      nextProps.isPath !== this.props.isPath ||\n      nextProps.isStart !== this.props.isStart ||\n      nextProps.isTargetReached !== this.props.isTargetReached ||\n      nextProps.isWeight !== this.props.isWeight ||\n      nextProps.isTarget !== this.props.isTarget ||\n      nextProps.direction !== this.props.direction\n    ) {\n      return true;\n    }\n    return true;\n  }\n\n  render() {\n    const {\n      isTarget,\n      isStart,\n      isWall,\n      isWeight,\n      isVisited,\n      isPath,\n      row,\n      col,\n      direction,\n      isTargetReached,\n    } = this.props;\n    const nodeType = isTargetReached\n      ? \"node-target-reached\"\n      : isPath && direction == \"landing-pad\"\n      ? \"node-path-landing-pad\"\n      : isTarget\n      ? \"node-target\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isWeight\n      ? \"node-weight\"\n      : isPath && direction == \"horizontal\"\n      ? \"node-path-horizontal\"\n      : isPath && direction == \"vertical\"\n      ? \"node-path-vertical\"\n      : isPath && direction == \"ul\"\n      ? \"node-path-ul\"\n      : isPath && direction == \"ur\"\n      ? \"node-path-ur\"\n      : isPath && direction == \"bl\"\n      ? \"node-path-bl\"\n      : isPath && direction == \"br\"\n      ? \"node-path-br\"\n      : \"\";\n    return (\n      <div\n        onDragStart={(e) => {\n          e.preventDefault();\n        }}\n        className=\"node-bounds\"\n        onMouseDown={this.handleOnMouseDown.bind(this)}\n        onMouseUp={this.handleOnMouseUp.bind(this)}\n        onMouseEnter={this.handleOnMouseEnter.bind(this)}\n      >\n        <div\n          className={`node ${nodeType} ${isVisited ? \"visited\" : \"unvisited\"}`}\n          id={`node-${row}-${col}`}\n        ></div>\n      </div>\n    );\n  }\n}\n","import React, { useState } from \"react\";\nimport \"./DropdownMenu.css\";\n\nexport default function DropdownMenu(props) {\n  const [dropdownIsVisible, setDropdownIsVisible] = useState(false);\n  const { title } = props;\n\n  const onClick = () => {\n    setDropdownIsVisible(!dropdownIsVisible);\n  };\n\n  return (\n    <div className=\"dropdown-menu\">\n      <button id=\"button\" onClick={onClick}>\n        {title}\n      </button>\n      {dropdownIsVisible ? (\n        <ul onClick={() => setDropdownIsVisible(false)}>\n          {props.children.map((child, index) => {\n            return <li key={index}>{child}</li>;\n          })}\n        </ul>\n      ) : null}\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./NavigationBar.css\";\n\nexport default function NavigationBar(props) {\n  return <div className=\"navigation-bar\">{props.children}</div>;\n}\n","export default __webpack_public_path__ + \"static/media/paintbrushes.8ab87ecc.svg\";","import React from \"react\";\nimport \"./Hint.css\";\n\nexport default function Hint(props) {\n  const { message } = props;\n  return <div className=\"hint-container\">{message}</div>;\n}\n","import React, { useState } from \"react\";\nimport \"./DrawToggle.css\";\nimport brushesImg from \"../../../Images/paintbrushes.svg\";\nimport Hint from \"../../Hints/Hint\";\n\nconst WALLS = \"Walls\";\nconst WEIGHTS = \"Weights\";\n\nexport default function Toggle(props) {\n  const [selected, setSelected] = useState(WALLS);\n  const [isHintDisplayed, setIsHintDisplayed] = useState(false);\n  const { setDrawMode } = props;\n\n  const toggleHint = () => {\n    setIsHintDisplayed(!isHintDisplayed);\n  };\n\n  return (\n    <div id=\"container\">\n      {isHintDisplayed ? <Hint message=\"Draw Mode\" /> : null}\n      <img\n        id=\"brushes-img\"\n        src={brushesImg}\n        width=\"14\"\n        height=\"14\"\n        onMouseEnter={toggleHint}\n        onMouseLeave={toggleHint}\n      />\n      <div className=\"toggle\">\n        <button\n          onClick={() => {\n            setSelected(WALLS);\n            setDrawMode(WALLS);\n          }}\n          className={selected === WALLS ? \"selected\" : \"unselected\"}\n        >\n          Walls\n        </button>\n        <button\n          onClick={() => {\n            setSelected(WEIGHTS);\n            setDrawMode(WEIGHTS);\n          }}\n          className={selected === WEIGHTS ? \"selected\" : \"unselected\"}\n        >\n          Weights\n        </button>\n      </div>\n    </div>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/weight-plates.4761408d.svg\";","import React, { useState } from \"react\";\nimport \"./Slider.css\";\nimport weightImg from \"../../../Images/weight-plates.svg\";\nimport Hint from \"../../Hints/Hint\";\n\nexport default function Slider(props) {\n  const [isHintDisplayed, setIsHintDisplayed] = useState(false);\n  const { value, setValue } = props;\n\n  const toggleHint = () => {\n    setIsHintDisplayed(!isHintDisplayed);\n  };\n\n  return (\n    <div id=\"weight-slider-section\">\n      {isHintDisplayed ? <Hint message=\"Weight Value\" /> : null}\n      <img\n        id=\"weightImg\"\n        src={weightImg}\n        width=\"14\"\n        height=\"14\"\n        onMouseEnter={toggleHint}\n        onMouseLeave={toggleHint}\n      />\n      <div className=\"slider-container\">\n        <input\n          className=\"slider\"\n          type=\"range\"\n          min={1}\n          max={20}\n          value={value}\n          onChange={(e) => {\n            setValue(e.target.valueAsNumber);\n          }}\n        />\n        <p id=\"value\">{value}</p>\n      </div>\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport \"./AlgorithmTitle.css\";\n\nconst DIJKSTRA = \"Dijkstra\";\nconst BFS = \"BFS\";\nconst DFS = \"DFS\";\nconst ASTAR = \"A*\";\n\nexport default function AlgorithmTitle(props) {\n  const { algorithm } = props;\n  const [infoIsDisplayed, setInfoIsDisplayed] = useState(false);\n\n  const dijkstraInfo =\n    \"Dijkstra's Algorithm finds the shortest path between between two given nodes.\".concat(\n      \" It does this by taking into account the weights of edges and using a priority queue that sorts neighboring nodes by distance.\".concat(\n        \" It then visits those nodes in ascending order of distance.\".concat(\n          \" In this visualization, nodes have a distance of 1 and weights have a distance of 5.\"\n        )\n      )\n    );\n  const bfsInfo =\n    \"Breadth First Search finds the shortest path between between two given nodes.\".concat(\n      \" It starts by adding neighboring nodes to a queue.\".concat(\n        \" It then pops the first node from the queue, visits it, and adds its neighbors to the queue.\"\n          .concat(\" This process repeats until the target node is reached.\")\n          .concat(\" Breadth First Search does not take weights into account.\")\n      )\n    );\n  const dfsInfo =\n    \"Depth First Search finds a path between between two given nodes, but it does not guarentee the shortest path.\".concat(\n      \" It does this by recursively visiting neighboring nodes instead of using a queue.\".concat(\n        \" This means that deep nodes will be reached before nearby nodes.\".concat(\n          \" Depth First Search does not take weights into account.\"\n        )\n      )\n    );\n  const aStarInfo =\n    \"A* Search Algorithm finds the shortest path between between two given nodes.\".concat(\n      \" It also has knowledge of where the end node is beforehand.\".concat(\n        \" It uses a queue similar to Dijkstra's algorithm, but instead assigns scores to neighboring nodes based on distance to the node along with estimated distance to the target node.\".concat(\n          \" In this visualization, nodes have a distance of 1 and weights have a distance of 5.\"\n        )\n      )\n    );\n\n  const getInfo = (algorithm) => {\n    switch (algorithm) {\n      case DIJKSTRA:\n        return dijkstraInfo;\n      case BFS:\n        return bfsInfo;\n      case DFS:\n        return dfsInfo;\n      case ASTAR:\n        return aStarInfo;\n    }\n  };\n\n  return (\n    <div id=\"bottom-left-fixed\">\n      <h1 id=\"big-algorithm-name\">{algorithm}</h1>\n      <div\n        onMouseEnter={() => setInfoIsDisplayed(true)}\n        onMouseLeave={() => setInfoIsDisplayed(false)}\n        className=\"info-icon\"\n      />\n      {infoIsDisplayed ? (\n        <p className=\"info-popup\">{getInfo(algorithm)}</p>\n      ) : null}\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./Credits.css\";\n\nexport default function Credits() {\n  return (\n    <div className=\"credits\">\n      <div className=\"credit\">\n        <a target=\"_blank\" href=\"https://icons8.com/icon/62234/launch\">\n          Launch\n        </a>{\" \"}\n        icon by{\" \"}\n        <a target=\"_blank\" href=\"https://icons8.com\">\n          Icons8\n        </a>\n      </div>\n      <div className=\"credit\">\n        <a target=\"_blank\" href=\"https://icons8.com/icon/100900/empty-flag\">\n          Empty Flag\n        </a>{\" \"}\n        icon by{\" \"}\n        <a target=\"_blank\" href=\"https://icons8.com\">\n          Icons8\n        </a>\n      </div>\n      <div className=\"credit\">\n        <a target=\"_blank\" href=\"https://icons8.com/icon/118838/vertical-line\">\n          Vertical Line\n        </a>{\" \"}\n        icon by{\" \"}\n        <a target=\"_blank\" href=\"https://icons8.com\">\n          Icons8\n        </a>\n      </div>\n      <div className=\"credit\">\n        Icons made by{\" \"}\n        <a href=\"https://www.freepik.com\" title=\"Freepik\">\n          Freepik\n        </a>{\" \"}\n        from{\" \"}\n        <a href=\"https://www.flaticon.com/\" title=\"Flaticon\">\n          www.flaticon.com\n        </a>\n      </div>\n      <div className=\"credit\">\n        Icons made by{\" \"}\n        <a href=\"\" title=\"Vitaly Gorbachev\">\n          Vitaly Gorbachev\n        </a>{\" \"}\n        from{\" \"}\n        <a href=\"https://www.flaticon.com/\" title=\"Flaticon\">\n          www.flaticon.com\n        </a>\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./NavigationSection.css\";\n\nexport default function NavigationSection(props) {\n  return <div className=\"navigation-section\">{props.children}</div>;\n}\n","// Used to put nodes in a priority queue based on distance.\nexport default class MinHeap {\n    constructor() {\n        this.heap = [null];\n    }\n\n    // Insert an element into the heap and fix the heap.\n    insert(node) {\n        this.heap.push(node);\n        let currIndex = this.heap.length - 1;\n        let parentIndex = Math.floor(currIndex / 2);\n        while (currIndex > 1 && node.distance < this.heap[parentIndex].distance) {\n            [this.heap[parentIndex], this.heap[currIndex]] = [this.heap[currIndex], this.heap[parentIndex]];\n            currIndex = parentIndex;\n            parentIndex = Math.floor(currIndex / 2);\n        }\n    }\n\n    // Pop minimum element from the front of the heap and fix the heap.\n    pop() {\n        if (this.heap.length > 2) {\n            const head = this.heap[1];\n            const tail = this.heap.splice(this.heap.length - 1)[0];\n            this.heap[1] = tail;\n\n            let currIndex = 1;\n            let leftChildIndex = currIndex * 2;\n            let rightChildIndex = currIndex * 2 + 1;\n            // While there are two child nodes, swap currNode with minChild if minChild is smaller.\n            while (this.heap[leftChildIndex] && this.heap[rightChildIndex]) {\n                let minChild = this.heap[leftChildIndex];\n                let minIndex = leftChildIndex;\n                if (this.heap[rightChildIndex].distance < minChild.distance) {\n                    minChild = this.heap[rightChildIndex];\n                    minIndex = rightChildIndex\n                }\n                if (this.heap[currIndex].distance > minChild.distance) {\n                    [this.heap[currIndex], this.heap[minIndex]] = [this.heap[minIndex], this.heap[currIndex]];\n                    currIndex = minIndex;\n                } else {\n                    break;\n                }\n                leftChildIndex = currIndex * 2;\n                rightChildIndex = currIndex * 2 + 1;\n            }\n            // If there is one child node, swap it with currNode if currNode is smaller.\n            if (this.heap[leftChildIndex] && (this.heap[currIndex].distance > this.heap[leftChildIndex].distance)) {\n                [this.heap[currIndex], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[currIndex]];\n            } else if (this.heap[rightChildIndex] && (this.heap[currIndex].distance > this.heap[rightChildIndex].distance)) {\n                [this.heap[currIndex], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[currIndex]];\n            }\n            return head;\n        } else if (this.heap.length === 2) {\n            return this.heap.splice(1, 1)[0];\n        } else {\n            return null;\n        }\n    }\n\n    // Returns true if the minheap is empty.\n    isEmpty() {\n        if (this.heap.length < 2) {\n            return true;\n        }\n        return false;\n    }\n}","// Returns ALL neighbors of 'node', visited or not. Neighbors\n// cannot have walls.\nexport function getNeighbors(node, numRows, numCols, grid) {\n    const {row, col} = node;\n    const neighbors = [];\n    // North neighbor.\n    if (isSafe(row + 1, col, numRows, numCols) && !grid[row + 1][col].isWall) {\n        neighbors.push(grid[row + 1][col]);\n    }\n    // South neighbor.\n    if (isSafe(row - 1, col, numRows, numCols) && !grid[row - 1][col].isWall) {\n        neighbors.push(grid[row - 1][col]);\n    }\n    // East neighbor.\n    if (isSafe(row, col + 1, numRows, numCols) && !grid[row][col + 1].isWall) {\n        neighbors.push(grid[row][col + 1]);\n    }\n    // West neighbor.\n    if (isSafe(row, col - 1, numRows, numCols) && !grid[row][col - 1].isWall) {\n        neighbors.push(grid[row][col - 1]);\n    }\n    return neighbors;\n}\n\n// Returns true if row and col are on the board.\nfunction isSafe(row, col, numRows, numCols) {\n    if (row >= 0 && row < numRows &&\n        col >= 0 && col < numCols) {\n        return true;\n    }\n    return false;\n}","import MinHeap from \"../Data Structures/MinHeap\";\nimport { getNeighbors } from \"./SearchHelperFunctions\";\n\n// Use dijkstra's algorithm to find the shortest path from 'startNode' to\n//'targetNode' in 'grid'. Return an array of the visited nodes in order as\n// well as the shortest path in reversed order.\nexport function dijkstra(\n  grid,\n  startNode,\n  targetNode,\n  numRows,\n  numCols,\n  weightValue\n) {\n  startNode.distance = 0;\n  const priorityQueue = new MinHeap();\n  const visitedNodesInOrder = [];\n  const shortestPathReversed = [];\n  priorityQueue.insert(startNode);\n  while (!priorityQueue.isEmpty()) {\n    const node = priorityQueue.pop();\n    visitedNodesInOrder.push(node);\n    if (node === targetNode) {\n      // The target node was discovered.\n      let pathNode = node;\n      while (pathNode !== startNode) {\n        shortestPathReversed.push(pathNode);\n        pathNode = pathNode.previousNode;\n      }\n      shortestPathReversed.push(pathNode);\n      return { visitedNodesInOrder, shortestPathReversed };\n    }\n    const neighbors = getNeighbors(node, numRows, numCols, grid);\n    for (const neighbor of neighbors) {\n      const weight = neighbor.isWeight ? weightValue : 1;\n      // Only update distance of neighbors if path results in lower distance.\n      if (node.distance + weight < neighbor.distance) {\n        neighbor.distance = node.distance + weight;\n        neighbor.previousNode = node;\n      }\n      // Only add unvisited nodes to the priority queue.\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        priorityQueue.insert(neighbor);\n      }\n      //priorityQueue.insert(neighbor);\n    }\n  }\n  // The target node could not be reached.\n  return { visitedNodesInOrder, shortestPathReversed };\n}\n","// Used as a first-in, first-out datastructure.\nexport default class Queue {\n    constructor() {\n        this.queue = new DoublyLinkedList();\n    }\n\n    enqueue(node) {\n        this.queue.insert(new ListNode(node));\n    }\n\n    dequeue() {\n        return this.queue.popHead();\n    }\n\n    isEmpty() {\n        return this.queue.isEmpty();\n    }\n}\n\nclass DoublyLinkedList {\n    constructor(head = null) {\n        this.head = head;\n        this.tail = head;\n    }\n\n    getHead() {\n        return this.head.getData();\n    }\n\n    // Inserts an element onto the end of the list.\n    insert(listNode) {\n        if (this.tail !== null) {\n            this.tail.setNext(listNode);\n            this.tail = listNode;\n        } else {\n            this.head = listNode;\n            this.tail = listNode;\n        }\n    }\n\n    // Removes the first element from the list.\n    popHead() {\n        const listNode = this.head;\n        if (listNode !== null) {\n            this.head = this.head.getNext();\n        }\n        if (this.head === null) {\n            this.tail = null;\n        }\n        return listNode.getData();\n    }\n\n    isEmpty() {\n        return this.head === null;\n    }\n}\n\n// The node to be used in the LinkedList.\nclass ListNode {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    setNext(next) {\n        this.next = next;\n    }\n\n    getNext() {\n        return this.next;\n    }\n\n    getData() {\n        return this.data;\n    }\n}","import Queue from '../Data Structures/Queue';\nimport { getNeighbors } from './SearchHelperFunctions';\n\n// Use breadth first search to find the shortest path from 'startNode' to 'targetNode'\n// in 'grid'. Return an array of the visited nodes in order as well as an array\n// of the shortest path in reversed order.\nexport function breadthFirstSearch(grid, startNode, targetNode, numRows, numCols) {\n    const visitedNodesInOrder = [];\n    const shortestPathReversed = [];\n    const q = new Queue();\n    q.enqueue(startNode);\n    startNode.isVisited = true;\n    while (!q.isEmpty()) {\n        const node = q.dequeue();\n        visitedNodesInOrder.push(node);\n        if (node === targetNode) {\n            // The target node was discovered.\n            let pathNode = node;\n            while (pathNode !== startNode) {\n                shortestPathReversed.push(pathNode);\n                pathNode = pathNode.previousNode;\n            }\n            shortestPathReversed.push(pathNode);\n            return {visitedNodesInOrder, shortestPathReversed};\n        }\n        const neighbors = getNeighbors(node, numRows, numCols, grid);\n        for (const neighbor of neighbors) {\n            if (!neighbor.isVisited) {\n                q.enqueue(neighbor);\n                neighbor.isVisited = true;\n                neighbor.previousNode = node;\n            }\n        }\n    }\n    // The target node could not be reached.\n    return {visitedNodesInOrder, shortestPathReversed};\n}\n\n// Add walls that can be placed.\n// Add bridges that take you from one node to another in shorter time.\n// Add weights that slow you down.","import {getNeighbors} from './SearchHelperFunctions';\n\n// Use depth first search to find a path from 'startNode' to 'targetNode'\n// in 'grid'. The path is not guaranteed to be the shortest path. Return \n// an array of the visited nodes in order as well as an array of the path \n// discovered in reversed order.\nexport function depthFirstSearch(grid, startNode, targetNode, numRows, numCols) {\n    const visitedNodesInOrder = [];\n    const pathReversed = [];\n    startNode.isVisited = true;\n    dfs(grid, startNode, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed);\n    pathReversed.push(startNode);\n    return {visitedNodesInOrder, pathReversed};\n}\n\n// Recursive function to be used for depth first search.\nfunction dfs(grid, node, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed) {\n    if (node === targetNode) {\n        // Target node was discovered.\n        pathReversed.push(node);\n        return true;\n    }\n    const neighbors = getNeighbors(node, numRows, numCols, grid);\n    for (const neighbor of neighbors) {\n        if (!neighbor.isVisited) {\n            neighbor.isVisited = true;\n            neighbor.previousNode = node;\n            visitedNodesInOrder.push(neighbor);\n            if (dfs(grid, neighbor, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed)) {\n                pathReversed.push(neighbor);\n                return true;\n            }\n        }\n    }\n    // Target node not found.\n    return false;\n}","import { getNeighbors } from \"./SearchHelperFunctions\";\n\nexport function aStar(\n  grid,\n  startNode,\n  targetNode,\n  numRows,\n  numCols,\n  weightValue\n) {\n  const priorityQueue = new MinHeap(targetNode);\n  const visitedNodesInOrder = [];\n  const shortestPathReversed = [];\n  // Start the algorithm at the startNode.\n  startNode.distance = 0;\n  startNode.isVisited = true;\n  priorityQueue.insert(startNode, targetNode);\n  // Traverse nodes until priority queue is empty.\n  while (!priorityQueue.isEmpty()) {\n    const node = priorityQueue.pop();\n    visitedNodesInOrder.push(node);\n    if (node === targetNode) {\n      // The target Node was discovered.\n      let pathNode = node;\n      while (pathNode !== startNode) {\n        shortestPathReversed.push(pathNode);\n        pathNode = pathNode.previousNode;\n      }\n      shortestPathReversed.push(pathNode);\n      return { visitedNodesInOrder, shortestPathReversed };\n    }\n    // Get neighboring nodes and add to priority queue if unvisited.\n    const neighbors = getNeighbors(node, numRows, numCols, grid);\n    for (const neighbor of neighbors) {\n      const weight = neighbor.isWeight ? weightValue : 1;\n      if (!neighbor.isVisited) {\n        // Update the neighbor's distance.\n        neighbor.distance = node.distance + weight;\n        neighbor.previousNode = node;\n        priorityQueue.insert(neighbor, targetNode);\n        neighbor.isVisited = true;\n      } else {\n        // Update neighbor's distance to minimum of possible routes to that neighbor.\n        if (node.distance + weight < neighbor.distance) {\n          neighbor.distance = node.distance + weight;\n          neighbor.previousNode = node;\n          // Insert the neighbor into the queue again.\n          priorityQueue.insert(neighbor, targetNode);\n        }\n      }\n    }\n  }\n  // The target node could not be reached.\n  return { visitedNodesInOrder, shortestPathReversed };\n}\n\n// G function for aStar that returns distance it took to get to specified node.\nfunction g(node) {\n  return node.distance;\n}\n\n// Heuristic function for aStar using Manhattan distance.\nfunction h(node, targetNode) {\n  const dx = Math.abs(targetNode.row - node.row);\n  const dy = Math.abs(targetNode.col - node.col);\n  return dx + dy;\n}\n\nfunction f(node, targetNode) {\n  return h(node, targetNode) + g(node);\n}\n\n// Used to put nodes in a priority queue based on f score (g + h). This priority queue does\n// not support reprioritizing. Instead, nodes in the queue with updated distances are inserted\n// into the queue a second time. This is okay because it won't really affect runtime.\nclass MinHeap {\n  constructor(targetNode) {\n    this.heap = [null];\n    this.targetNode = targetNode;\n  }\n\n  // Insert an element into the heap and fix the heap.\n  insert(node, targetNode) {\n    this.heap.push(node);\n    let currIndex = this.heap.length - 1;\n    let parentIndex = Math.floor(currIndex / 2);\n    while (\n      currIndex > 1 &&\n      f(node, targetNode) <= f(this.heap[parentIndex], targetNode)\n    ) {\n      [this.heap[parentIndex], this.heap[currIndex]] = [\n        this.heap[currIndex],\n        this.heap[parentIndex],\n      ];\n      currIndex = parentIndex;\n      parentIndex = Math.floor(currIndex / 2);\n    }\n  }\n\n  // Pop minimum element from the front of the heap and fix the heap.\n  pop() {\n    if (this.heap.length > 2) {\n      const head = this.heap[1];\n      const tail = this.heap.splice(this.heap.length - 1)[0];\n      this.heap[1] = tail;\n\n      let currIndex = 1;\n      let leftChildIndex = currIndex * 2;\n      let rightChildIndex = currIndex * 2 + 1;\n      // While there are two child nodes, swap currNode with minChild if minChild is smaller.\n      while (this.heap[leftChildIndex] && this.heap[rightChildIndex]) {\n        let minChild = this.heap[leftChildIndex];\n        let minIndex = leftChildIndex;\n        if (\n          f(this.heap[rightChildIndex], this.targetNode) <\n          f(minChild, this.targetNode)\n        ) {\n          minChild = this.heap[rightChildIndex];\n          minIndex = rightChildIndex;\n        }\n        if (\n          f(this.heap[currIndex], this.targetNode) >\n          f(minChild, this.targetNode)\n        ) {\n          [this.heap[currIndex], this.heap[minIndex]] = [\n            this.heap[minIndex],\n            this.heap[currIndex],\n          ];\n          currIndex = minIndex;\n        } else {\n          break;\n        }\n        leftChildIndex = currIndex * 2;\n        rightChildIndex = currIndex * 2 + 1;\n      }\n      // If there is one child node, swap it with currNode if currNode is smaller.\n      if (\n        this.heap[leftChildIndex] &&\n        f(this.heap[currIndex], this.targetNode) >\n          f(this.heap[leftChildIndex], this.targetNode)\n      ) {\n        [this.heap[currIndex], this.heap[leftChildIndex]] = [\n          this.heap[leftChildIndex],\n          this.heap[currIndex],\n        ];\n      } else if (\n        this.heap[rightChildIndex] &&\n        f(this.heap[currIndex], this.targetNode) >\n          f(this.heap[rightChildIndex], this.targetNode)\n      ) {\n        [this.heap[currIndex], this.heap[rightChildIndex]] = [\n          this.heap[rightChildIndex],\n          this.heap[currIndex],\n        ];\n      }\n      return head;\n    } else if (this.heap.length === 2) {\n      return this.heap.splice(1, 1)[0];\n    } else {\n      return null;\n    }\n  }\n\n  // Returns true if the minheap is empty.\n  isEmpty() {\n    if (this.heap.length < 2) {\n      return true;\n    }\n    return false;\n  }\n}\n","// Returns an array of lines, given a path of nodes.\nexport function pathToLines(pathReversed) {\n  const lines = [];\n  const directions = [];\n  directions.push(\"none\");\n  for (let i = 1; i < pathReversed.length; i++) {\n    // Get the direction of the path given current and previous nodes.\n    let prevNode = pathReversed[i - 1];\n    let currNode = pathReversed[i];\n    let dRow = prevNode.row - currNode.row;\n    let dCol = currNode.col - prevNode.col;\n    const direction =\n      dCol === 1\n        ? \"right\"\n        : dCol === -1\n        ? \"left\"\n        : dRow === 1\n        ? \"up\"\n        : dRow === -1\n        ? \"down\"\n        : \"\";\n    directions.push(direction);\n    // Given directions of current node and previous node, get the corresponding line.\n    const line =\n      direction === \"right\" && directions[i - 1] === \"none\"\n        ? \"horizontal\"\n        : direction === \"right\" && directions[i - 1] === \"right\"\n        ? \"horizontal\"\n        : direction === \"right\" && directions[i - 1] === \"up\"\n        ? \"ul\"\n        : direction === \"right\" && directions[i - 1] === \"down\"\n        ? \"bl\"\n        : direction === \"left\" && directions[i - 1] === \"none\"\n        ? \"horizontal\"\n        : direction === \"left\" && directions[i - 1] === \"left\"\n        ? \"horizontal\"\n        : direction === \"left\" && directions[i - 1] === \"up\"\n        ? \"ur\"\n        : direction === \"left\" && directions[i - 1] === \"down\"\n        ? \"br\"\n        : direction === \"up\" && directions[i - 1] === \"none\"\n        ? \"vertical\"\n        : direction === \"up\" && directions[i - 1] === \"up\"\n        ? \"vertical\"\n        : direction === \"up\" && directions[i - 1] === \"left\"\n        ? \"bl\"\n        : direction === \"up\" && directions[i - 1] === \"right\"\n        ? \"br\"\n        : direction === \"down\" && directions[i - 1] === \"none\"\n        ? \"vertical\"\n        : direction === \"down\" && directions[i - 1] === \"down\"\n        ? \"vertical\"\n        : direction === \"down\" && directions[i - 1] === \"left\"\n        ? \"ul\"\n        : direction === \"down\" && directions[i - 1] === \"right\"\n        ? \"ur\"\n        : \"\";\n    lines.push(line);\n  }\n  lines.push(\"landing-pad\");\n  return lines;\n}\n","function NodeObj(col, row) {\n  this.col = col;\n  this.row = row;\n  this.isStart = false;\n  this.isTarget = false;\n  this.isVisited = false;\n  this.isTargetReached = false;\n  this.isWall = false;\n  this.isWeight = false;\n  this.distance = Infinity;\n  this.previousNode = null;\n  this.direction = null;\n}\n\n/*----- These functions modify the grid AND set the state. -----*/\n\n// Creates anitial 2D array of node objects and sets state.\nexport function createInitialGrid(numRows, numCols) {\n  const grid = [];\n  for (let r = 0; r < numRows; r++) {\n    const row = [];\n    for (let c = 0; c < numCols; c++) {\n      const node = new NodeObj(c, r);\n      node.isStart =\n        r === this.state.startNodeRow && c === this.state.startNodeCol;\n      node.isTarget =\n        r === this.state.targetNodeRow && c === this.state.targetNodeCol;\n      row.push(node);\n    }\n    grid.push(row);\n  }\n  this.setState({ grid: grid });\n}\n\n// Clears all weights on grid and set state.\nexport function clearWeights() {\n  const grid = this.copyGrid();\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.isWeight) {\n        node.isWeight = false;\n      }\n    }\n  }\n  this.setState({ grid: grid });\n}\n\n// Clears all path nodes on grid and set state.\nexport function clearPath() {\n  const grid = this.copyGrid();\n  this.resetNodes(grid);\n  this.setState({ grid: grid });\n}\n\n// Clears all walls on grid and set state.\nexport function clearWalls() {\n  const grid = this.copyGrid();\n  for (const row of grid) {\n    for (const node of row) {\n      if (node.isWall) {\n        node.isWall = false;\n      }\n    }\n  }\n  this.setState({ grid: grid });\n}\n\n/*----- These functions return a modified grid. -----*/\n\n// Creates and returns a deep copy of the current grid.\nexport function copyGrid() {\n  const { grid } = this.state;\n  const gridCopy = [];\n  for (const row of grid) {\n    const rowCopy = row.map((node) => {\n      const nodeCopy = Object.assign({}, node);\n      return nodeCopy;\n    });\n    gridCopy.push(rowCopy);\n  }\n  return gridCopy;\n}\n\n// Returns a grid with all nodes set to !visited and !isPath.\nexport function resetNodes(grid) {\n  for (const row of grid) {\n    for (const node of row) {\n      // We have to reset isVisited, and isPath of nodes the same way we set them.\n      if (!node.isWall && !node.isStart && !node.isTarget && !node.isWeight) {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node\";\n      } else if (node.isWeight) {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-weight unvisited\";\n      }\n      node.isVisited = false;\n      node.isPath = false;\n      node.previousNode = null;\n      node.distance = Infinity;\n      node.isStart =\n        node.row === this.state.startNodeRow &&\n        node.col === this.state.startNodeCol;\n      node.isTarget =\n        node.row === this.state.targetNodeRow &&\n        node.col === this.state.targetNodeCol;\n      node.isTargetReached = false;\n    }\n  }\n}\n","import React, { Component } from \"react\";\n\n// Components\nimport Node from \"./Components/Node/Node\";\nimport DropdownMenu from \"./Components/Buttons/DropdownMenu/DropdownMenu\";\nimport NavigationBar from \"./Components/Navigation/NavigationBar/NavigationBar\";\nimport DrawToggle from \"./Components/Buttons/DrawToggle/DrawToggle\";\nimport Slider from \"./Components/Buttons/Slider/Slider\";\nimport AlgorithmTitle from \"./Components/AlgorithmTitle/AlgorithmTitle\";\nimport Credits from \"./Components/Credits/Credits\";\nimport NavigationSection from \"./Components/Navigation/NavigationSection\";\n\n// Functions\nimport { dijkstra } from \"./Search Algorithms/Dijkstra\";\nimport { breadthFirstSearch } from \"./Search Algorithms/BreadthFirstSearch\";\nimport { depthFirstSearch } from \"./Search Algorithms/DepthFirstSearch\";\nimport { aStar } from \"./Search Algorithms/AStar\";\nimport { getScreenWidth, getScreenHeight } from \"./Functions/ScreenFunctions\";\nimport { pathToLines } from \"./Functions/HelperFunctions\";\nimport {\n  copyGrid,\n  clearWeights,\n  clearPath,\n  clearWalls,\n  createInitialGrid,\n  resetNodes,\n} from \"./Functions/GridFunctions\";\n\n// CSS\nimport \"./Components/Buttons/Button Styles/VisualizeButton.css\";\nimport \"./PathfindingVisualizer.css\";\n\nconst NODE_WIDTH = 30;\n\nconst NUM_ROWS = Math.floor(getScreenHeight() / NODE_WIDTH);\nconst NUM_COLS = Math.floor(getScreenWidth() / NODE_WIDTH);\n\nconst INITIAL_START_ROW = 5;\nconst INITIAL_START_COL = 1;\nconst INITIAL_TARGET_ROW = NUM_ROWS - 2;\nconst INITIAL_TARGET_COL = NUM_COLS - 2;\n\nconst ALGORITHM = {\n  DIJKSTRA: \"Dijkstra\",\n  BFS: \"BFS\",\n  DFS: \"DFS\",\n  ASTAR: \"A*\",\n};\n\nconst DRAW_MODE = {\n  WALLS: \"Walls\",\n  WEIGHTS: \"Weights\",\n};\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      startNodeRow: INITIAL_START_ROW,\n      startNodeCol: INITIAL_START_COL,\n      targetNodeRow: INITIAL_TARGET_ROW,\n      targetNodeCol: INITIAL_TARGET_COL,\n      launchPadRow: null,\n      launchPadCol: null,\n      mouseDown: false,\n      algorithm: ALGORITHM.DIJKSTRA,\n      drawMode: DRAW_MODE.WALLS,\n      isMovingStart: false,\n      isMovingTarget: false,\n      isMovingLaunchPad: false,\n      weightValue: 5,\n    };\n    // Bind 'this' in constructor to avoid binding on every render.\n    this.copyGrid = copyGrid.bind(this);\n    this.clearWeights = clearWeights.bind(this);\n    this.clearPath = clearPath.bind(this);\n    this.clearWalls = clearWalls.bind(this);\n    this.createInitialGrid = createInitialGrid.bind(this);\n    this.resetNodes = resetNodes.bind(this);\n  }\n\n  setUp() {\n    document.body.onmouseup = this.handleOnMouseUp.bind(this);\n    document.body.onmouseleave = this.handleOnMouseUp.bind(this);\n  }\n\n  componentDidMount() {\n    this.setUp();\n    this.createInitialGrid(NUM_ROWS, NUM_COLS);\n  }\n\n  render() {\n    const { grid } = this.state;\n    return (\n      <div>\n        <NavigationBar>\n          <NavigationSection>\n            <DropdownMenu title={this.state.algorithm}>\n              <button onClick={this.setAlgorithmDijkstra}>Dijkstra</button>\n              <button onClick={this.setAlgorithmBFS}>BFS</button>\n              <button onClick={this.setAlgorithmDFS}>DFS</button>\n              <button onClick={this.setAlgorithmAStar}>A*</button>\n            </DropdownMenu>\n            <button id=\"visualize-button\" onClick={this.visualizeAlgorithm}>\n              Go\n            </button>\n          </NavigationSection>\n\n          <NavigationSection>\n            <button onClick={this.clearPath}>Clear Path</button>\n            <button onClick={this.clearWalls}>Clear Walls</button>\n            <button onClick={this.clearWeights}>Clear Weights</button>\n          </NavigationSection>\n\n          <NavigationSection>\n            <DrawToggle setDrawMode={this.setDrawMode} />\n          </NavigationSection>\n\n          <NavigationSection>\n            <Slider\n              value={this.state.weightValue}\n              setValue={this.setWeightValue}\n            />\n          </NavigationSection>\n\n          <NavigationSection>\n            {/*\n            <DropdownMenu title=\"More\">\n              <button>Credits</button>\n              <a href=\"https://github.com/allenchung01\">\n                <button>GitHub</button>\n              </a>\n            </DropdownMenu>*/}\n          </NavigationSection>\n        </NavigationBar>\n        {this.displayGrid(grid)}\n        <AlgorithmTitle algorithm={this.state.algorithm} />\n        <Credits />\n      </div>\n    );\n  }\n\n  // OnClick handlers.\n  setAlgorithmDijkstra = () => {\n    this.setState({ algorithm: ALGORITHM.DIJKSTRA });\n  };\n  setAlgorithmBFS = () => {\n    this.setState({ algorithm: ALGORITHM.BFS });\n  };\n  setAlgorithmDFS = () => {\n    this.setState({ algorithm: ALGORITHM.DFS });\n  };\n  setAlgorithmAStar = () => {\n    this.setState({ algorithm: ALGORITHM.ASTAR });\n  };\n  visualizeAlgorithm = () => {\n    this.visualize(this.state.algorithm);\n  };\n  setDrawMode = (mode) => {\n    this.setState({ drawMode: mode });\n  };\n  setWeightValue = (value) => {\n    this.setState({ weightValue: value });\n  };\n\n  // Visualizes the algorithm with discovery animations.\n  visualize(algorithm) {\n    // Reset the grid before visualizing.\n    let grid = this.copyGrid();\n    this.resetNodes(grid);\n    this.setState({ grid: grid }, () => {\n      // Make another copy of grid to perform algorithm on.\n      grid = this.copyGrid();\n      const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\n      const targetNode =\n        grid[this.state.targetNodeRow][this.state.targetNodeCol];\n\n      switch (algorithm) {\n        case ALGORITHM.DIJKSTRA:\n          this.visualizeDijkstra(grid, startNode, targetNode);\n          break;\n        case ALGORITHM.BFS:\n          this.visualizeBreadthFirstSearch(grid, startNode, targetNode);\n          break;\n        case ALGORITHM.DFS:\n          this.visualizeDepthFirstSearch(grid, startNode, targetNode);\n          break;\n        case ALGORITHM.ASTAR:\n          this.visualizeAStar(grid, startNode, targetNode);\n          break;\n        default:\n          return;\n      }\n    });\n  }\n\n  // Displays the algorithm's path without discovery animations.\n  redrawPath(algorithm) {\n    let grid = this.copyGrid();\n    const startNode = grid[this.state.launchPadRow][this.state.launchPadCol];\n    const targetNode = grid[this.state.targetNodeRow][this.state.targetNodeCol];\n\n    // Get the path of the given algorithm.\n    var pathReversed;\n    switch (algorithm) {\n      case ALGORITHM.DIJKSTRA:\n        pathReversed = dijkstra(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS,\n          this.state.weightValue\n        ).shortestPathReversed;\n        break;\n      case ALGORITHM.BFS:\n        pathReversed = breadthFirstSearch(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS\n        ).shortestPathReversed;\n        break;\n      case ALGORITHM.DFS:\n        pathReversed = depthFirstSearch(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS\n        ).pathReversed;\n        break;\n      case ALGORITHM.ASTAR:\n        pathReversed = aStar(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS,\n          this.state.weightValue\n        ).shortestPathReversed;\n        break;\n      default:\n        return;\n    }\n\n    const lines = pathToLines(pathReversed);\n\n    // Set the grid to the new grid with updated path.\n    grid = this.copyGrid();\n    for (let i = 0; i < pathReversed.length; i++) {\n      const row = pathReversed[i].row;\n      const col = pathReversed[i].col;\n      grid[row][col].direction = lines[i];\n      grid[row][col].isPath = true;\n    }\n    this.setState({ grid: grid });\n  }\n\n  /*----- Algorithm Methods -----*/\n\n  visualizeDijkstra(grid, startNode, targetNode) {\n    const { visitedNodesInOrder, shortestPathReversed } = dijkstra(\n      grid,\n      startNode,\n      targetNode,\n      NUM_ROWS,\n      NUM_COLS,\n      this.state.weightValue\n    );\n    this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n  }\n\n  visualizeBreadthFirstSearch(grid, startNode, targetNode) {\n    const { visitedNodesInOrder, shortestPathReversed } = breadthFirstSearch(\n      grid,\n      startNode,\n      targetNode,\n      NUM_ROWS,\n      NUM_COLS\n    );\n    this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n  }\n\n  visualizeDepthFirstSearch(grid, startNode, targetNode) {\n    const { visitedNodesInOrder, pathReversed } = depthFirstSearch(\n      grid,\n      startNode,\n      targetNode,\n      NUM_ROWS,\n      NUM_COLS\n    );\n    this.animateSearch(visitedNodesInOrder, pathReversed);\n  }\n\n  visualizeAStar(grid, startNode, targetNode) {\n    const { visitedNodesInOrder, shortestPathReversed } = aStar(\n      grid,\n      startNode,\n      targetNode,\n      NUM_ROWS,\n      NUM_COLS,\n      this.state.weightValue\n    );\n    this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n  }\n\n  /*----- Animation Methods -----*/\n\n  // Animates the discovery of nodes in the given list.\n  animateSearch(visitedNodesInOrder, pathReversed) {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (i === visitedNodesInOrder.length - 1) {\n          // Animate the path after discovery animation is complete.\n          this.animatePath(pathReversed);\n        } else {\n          if (!node.isStart && !node.isTarget) {\n            // Normally shouldn't do this, but had to to optimize performance.\n            const element = document.getElementById(\n              `node-${node.row}-${node.col}`\n            );\n            element.classList.remove(\"unvisited\");\n            element.classList.add(\"visited\");\n          }\n        }\n      }, 5 * i);\n    }\n  }\n\n  // Animates the final path from start to target node.\n  animatePath(pathReversed) {\n    const lines = pathToLines(pathReversed);\n    for (let i = pathReversed.length - 1; i >= 0; i--) {\n      setTimeout(\n        () => this.moveRocketShip(pathReversed, lines, i),\n        3000 * ((pathReversed.length - i) / pathReversed.length)\n      );\n    }\n  }\n\n  // Moves the rocket ship one space given the path, lines, and position.\n  moveRocketShip(pathReversed, lines, i) {\n    const node = pathReversed[i];\n    if (!node.isStart) {\n      const prevNode = pathReversed[i + 1];\n      const grid = this.copyGrid();\n      grid[prevNode.row][prevNode.col].isStart = false;\n      grid[prevNode.row][prevNode.col].isPath = true;\n      grid[prevNode.row][prevNode.col].direction = lines[i + 1];\n      grid[node.row][node.col].isStart = true;\n      if (grid[node.row][node.col].isTarget) {\n        grid[node.row][node.col].isTargetReached = true;\n      }\n      if (grid[prevNode.row][prevNode.col].direction === \"landing-pad\") {\n        this.setState({\n          grid: grid,\n          launchPadRow: prevNode.row,\n          launchPadCol: prevNode.col,\n        });\n        return;\n      }\n      this.setState({ grid: grid });\n    }\n  }\n\n  /*----- Mouse Handlers -----*/\n\n  // Handles onMouseDown event on node at given coordinates.\n  handleOnMouseDown(row, col) {\n    const grid = this.copyGrid();\n    const node = grid[row][col];\n\n    // Start moving start, target or launchpad nodes.\n    if (node.isTarget) {\n      this.setState({ isMovingTarget: true, mouseDown: true });\n      return;\n    }\n    if (node.isPath && node.direction === \"landing-pad\") {\n      this.setState({ isMovingLaunchPad: true, mouseDown: true });\n      return;\n    }\n    if (node.isStart) {\n      this.setState({ isMovingStart: true, mouseDown: true });\n      return;\n    }\n\n    // Start drawing walls or weights.\n    switch (this.state.drawMode) {\n      case DRAW_MODE.WALLS:\n        node.isWall = !node.isWall;\n        node.isWeight = false;\n        this.setState({ grid: grid, mouseDown: true });\n        break;\n      case DRAW_MODE.WEIGHTS:\n        node.isWeight = !node.isWeight;\n        node.isWall = false;\n        this.setState({ grid: grid, mouseDown: true });\n        break;\n      default:\n        return;\n    }\n  }\n\n  handleOnMouseUp() {\n    if (this.state.mouseDown === true) {\n      this.setState({\n        mouseDown: false,\n        isMovingStart: false,\n        isMovingTarget: false,\n        isMovingLaunchPad: false,\n      });\n    }\n  }\n\n  // Handle onMouseEnter for node at given coordinates.\n  handleOnMouseEnter(row, col) {\n    if (this.state.mouseDown === true) {\n      const grid = this.copyGrid();\n      const node = grid[row][col];\n\n      // Move target node.\n      if (this.state.isMovingTarget) {\n        // Remove path.\n        for (const row of grid) {\n          for (var node_ of row) {\n            node_.isPath = false;\n            node_.direction = null;\n            node_.isVisited = false;\n          }\n        }\n        // Reposition target node.\n        const prevTarget =\n          grid[this.state.targetNodeRow][this.state.targetNodeCol];\n        if (!prevTarget.isTargetReached) {\n          // Target was never reached, no need to redraw.\n          prevTarget.isTarget = false;\n          node.isTarget = true;\n          this.setState({ grid: grid, targetNodeRow: row, targetNodeCol: col });\n          return;\n        }\n        prevTarget.isTarget = false;\n        prevTarget.isTargetReached = false;\n        prevTarget.isStart = false;\n        node.isTarget = true;\n        node.isTargetReached = true;\n        this.setState(\n          {\n            grid: grid,\n            targetNodeRow: row,\n            targetNodeCol: col,\n          },\n          () => {\n            // Redraw the rest of the path.\n            this.redrawPath(this.state.algorithm);\n          }\n        );\n        return;\n      }\n\n      // Move launch pad.\n      if (this.state.isMovingLaunchPad) {\n        // Remove path.\n        for (const row of grid) {\n          for (var node_ of row) {\n            node_.isPath = false;\n            node_.direction = null;\n            node_.isVisited = false;\n          }\n        }\n        // Reposition the launch pad.\n        const prevLaunchPad =\n          grid[this.state.launchPadRow][this.state.launchPadCol];\n        prevLaunchPad.isPath = false;\n        prevLaunchPad.direction = null;\n        node.isPath = true;\n        node.direction = \"landing-pad\";\n        // Reposition the start node.\n        const prevStart =\n          grid[this.state.startNodeRow][this.state.startNodeCol];\n        prevStart.isStart = false;\n        node.isStart = true;\n        this.setState(\n          {\n            grid: grid,\n            launchPadRow: row,\n            launchPadCol: col,\n            startNodeRow: row,\n            startNodeCol: col,\n          },\n          // Redraw the rest of the path.\n          () => {\n            this.redrawPath(this.state.algorithm);\n          }\n        );\n        return;\n      }\n\n      // Move start node.\n      if (this.state.isMovingStart) {\n        const prevStart =\n          grid[this.state.startNodeRow][this.state.startNodeCol];\n        prevStart.isStart = false;\n        node.isStart = true;\n        this.setState({ grid: grid, startNodeRow: row, startNodeCol: col });\n        return;\n      }\n\n      // Continue drawing walls or weights.\n      switch (this.state.drawMode) {\n        case DRAW_MODE.WALLS:\n          node.isWall = !node.isWall;\n          node.isWeight = false;\n          this.setState({ grid: grid });\n          break;\n        case DRAW_MODE.WEIGHTS:\n          node.isWeight = !node.isWeight;\n          node.isWall = false;\n          this.setState({ grid: grid });\n          break;\n        default:\n          return;\n      }\n    }\n  }\n\n  // Map the grid to Node components that are displayed.\n  displayGrid(grid) {\n    return (\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => {\n          return (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, nodeIndex) => {\n                return (\n                  <Node\n                    draggable=\"false\"\n                    key={nodeIndex}\n                    isStart={node.isStart}\n                    isTarget={node.isTarget}\n                    isWall={node.isWall}\n                    isWeight={node.isWeight}\n                    isVisited={node.isVisited}\n                    isPath={node.isPath}\n                    row={node.row}\n                    col={node.col}\n                    direction={node.direction}\n                    isTargetReached={node.isTargetReached}\n                    handleOnMouseDown={this.handleOnMouseDown.bind(this)}\n                    handleOnMouseUp={this.handleOnMouseUp.bind(this)}\n                    handleOnMouseEnter={this.handleOnMouseEnter.bind(this)}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n}\n","// Returns the width of browser window.\nexport function getScreenWidth() {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth\n  );\n}\n\n// Returns the height of the browser window.\nexport function getScreenHeight() {\n  return window.innerHeight;\n}\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}