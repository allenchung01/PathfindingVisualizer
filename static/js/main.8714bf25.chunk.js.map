{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/Data Structures/MinHeap.js","PathfindingVisualizer/Search Algorithms/SearchHelperFunctions.js","PathfindingVisualizer/Data Structures/Queue.js","PathfindingVisualizer/Search Algorithms/DepthFirstSearch.js","PathfindingVisualizer/Search Algorithms/AStar.js","PathfindingVisualizer/PathfindingVisualizer.jsx","PathfindingVisualizer/Search Algorithms/Dijkstra.js","PathfindingVisualizer/Search Algorithms/BreadthFirstSearch.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","setState","isWall","handleOnMouseDown","row","col","handleOnMouseUp","handleOnMouseEnter","nextProps","nextState","isVisited","isPath","isStart","isTargetReached","isTarget","direction","nodeType","className","onMouseDown","bind","onMouseUp","onMouseEnter","id","Component","MinHeap","heap","node","push","currIndex","length","parentIndex","Math","floor","distance","head","tail","splice","leftChildIndex","rightChildIndex","minChild","minIndex","getNeighbors","numRows","numCols","grid","neighbors","isSafe","Queue","queue","DoublyLinkedList","insert","ListNode","popHead","isEmpty","getData","listNode","setNext","getNext","data","next","depthFirstSearch","startNode","targetNode","visitedNodesInOrder","pathReversed","dfs","neighbor","previousNode","f","abs","h","g","NUM_ROWS","NUM_COLS","max","document","body","scrollWidth","documentElement","offsetWidth","clientWidth","TARGET_NODE_ROW","TARGET_NODE_COL","PathfindingVisualizer","mouseDown","createInitialGrid","onmouseup","onmouseleave","onClick","visualizeDijkstra","visualizeBreadthFirstSearch","visualizeDepthFirstSearch","visualizeAStar","clearWalls","clearPath","displayGrid","target","href","copyGrid","resetNodes","priorityQueue","shortestPathReversed","pop","pathNode","dijkstra","animateSearch","q","enqueue","dequeue","breadthFirstSearch","aStar","i","setTimeout","animatePath","getElementById","lines","pathToLines","moveRocketShip","prevNode","directions","currNode","dRow","dCol","line","currentRow","NodeObj","nodes","map","rowIndex","nodeIndex","draggable","Infinity","copiedGrid","copiedRow","Object","assign","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.8714bf25.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    toggleWall() {\n        this.setState({isWall: !this.props.isWall,});\n    }\n\n    handleOnMouseDown() {\n        this.props.handleOnMouseDown(this.props.row, this.props.col);\n    }\n\n    handleOnMouseUp() {\n        this.props.handleOnMouseUp();\n    }\n\n    handleOnMouseEnter() {\n        this.props.handleOnMouseEnter(this.props.row, this.props.col);\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        if (nextProps.isWall !== this.props.isWall ||\n            nextProps.isVisited !== this.props.isVisited ||\n            nextProps.isPath !== this.props.isPath ||\n            nextProps.isStart !== this.props.isStart ||\n            nextProps.isTargetReached !== this.props.isTargetReached) {\n            return true;\n        }\n        return false;\n    }\n\n    render() {\n        const {isTarget, isStart, isWall, isVisited, isPath, row, col, direction, isTargetReached} = this.props;\n        const nodeType = \n            isTargetReached ? 'node-target-reached' :\n            isTarget ? 'node-target' : \n            isStart ? 'node-start' : \n            isWall ? 'node-wall':\n            isPath && direction == \"horizontal\" ? 'node-path-horizontal':\n            isPath && direction == \"vertical\" ? 'node-path-vertical':\n            isPath && direction == \"ul\" ? 'node-path-ul':\n            isPath && direction == \"ur\" ? 'node-path-ur':\n            isPath && direction == \"bl\" ? 'node-path-bl':\n            isPath && direction == \"br\" ? 'node-path-br':\n            isPath && direction == \"landing-pad\" ? 'node-path-landing-pad':\n            isVisited ? 'node-visited': \n            '';\n        return (\n            <div\n            className = 'node-bounds' \n            onMouseDown = {this.handleOnMouseDown.bind(this)}\n            onMouseUp = {this.handleOnMouseUp.bind(this)}\n            onMouseEnter = {this.handleOnMouseEnter.bind(this)}>\n                <div \n                className = {`node ${nodeType}`}\n                id={`node-${row}-${col}`}>      \n                </div>\n            </div>)\n\n    }\n}","// Used to put nodes in a priority queue based on distance.\nexport default class MinHeap {\n    constructor() {\n        this.heap = [null];\n    }\n\n    // Insert an element into the heap and fix the heap.\n    insert(node) {\n        this.heap.push(node);\n        let currIndex = this.heap.length - 1;\n        let parentIndex = Math.floor(currIndex / 2);\n        while (currIndex > 1 && node.distance < this.heap[parentIndex].distance) {\n            [this.heap[parentIndex], this.heap[currIndex]] = [this.heap[currIndex], this.heap[parentIndex]];\n            currIndex = parentIndex;\n            parentIndex = Math.floor(currIndex / 2);\n        }\n    }\n\n    // Pop minimum element from the front of the heap and fix the heap.\n    pop() {\n        if (this.heap.length > 2) {\n            const head = this.heap[1];\n            const tail = this.heap.splice(this.heap.length - 1)[0];\n            this.heap[1] = tail;\n\n            let currIndex = 1;\n            let leftChildIndex = currIndex * 2;\n            let rightChildIndex = currIndex * 2 + 1;\n            // While there are two child nodes, swap currNode with minChild if minChild is smaller.\n            while (this.heap[leftChildIndex] && this.heap[rightChildIndex]) {\n                let minChild = this.heap[leftChildIndex];\n                let minIndex = leftChildIndex;\n                if (this.heap[rightChildIndex].distance < minChild.distance) {\n                    minChild = this.heap[rightChildIndex];\n                    minIndex = rightChildIndex\n                }\n                if (this.heap[currIndex].distance > minChild.distance) {\n                    [this.heap[currIndex], this.heap[minIndex]] = [this.heap[minIndex], this.heap[currIndex]];\n                    currIndex = minIndex;\n                } else {\n                    break;\n                }\n                leftChildIndex = currIndex * 2;\n                rightChildIndex = currIndex * 2 + 1;\n            }\n            // If there is one child node, swap it with currNode if currNode is smaller.\n            if (this.heap[leftChildIndex] && (this.heap[currIndex].distance > this.heap[leftChildIndex].distance)) {\n                [this.heap[currIndex], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[currIndex]];\n            } else if (this.heap[rightChildIndex] && (this.heap[currIndex].distance > this.heap[rightChildIndex].distance)) {\n                [this.heap[currIndex], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[currIndex]];\n            }\n            return head;\n        } else if (this.heap.length === 2) {\n            return this.heap.splice(1, 1)[0];\n        } else {\n            return null;\n        }\n    }\n\n    // Returns true if the minheap is empty.\n    isEmpty() {\n        if (this.heap.length < 2) {\n            return true;\n        }\n        return false;\n    }\n}","// Returns ALL neighbors of 'node', visited or not. Neighbors\n// cannot have walls.\nexport function getNeighbors(node, numRows, numCols, grid) {\n    const {row, col} = node;\n    const neighbors = [];\n    // North neighbor.\n    if (isSafe(row + 1, col, numRows, numCols) && !grid[row + 1][col].isWall) {\n        neighbors.push(grid[row + 1][col]);\n    }\n    // South neighbor.\n    if (isSafe(row - 1, col, numRows, numCols) && !grid[row - 1][col].isWall) {\n        neighbors.push(grid[row - 1][col]);\n    }\n    // East neighbor.\n    if (isSafe(row, col + 1, numRows, numCols) && !grid[row][col + 1].isWall) {\n        neighbors.push(grid[row][col + 1]);\n    }\n    // West neighbor.\n    if (isSafe(row, col - 1, numRows, numCols) && !grid[row][col - 1].isWall) {\n        neighbors.push(grid[row][col - 1]);\n    }\n    return neighbors;\n}\n\n// Returns true if row and col are on the board.\nfunction isSafe(row, col, numRows, numCols) {\n    if (row >= 0 && row < numRows &&\n        col >= 0 && col < numCols) {\n        return true;\n    }\n    return false;\n}","// Used as a first-in, first-out datastructure.\nexport default class Queue {\n    constructor() {\n        this.queue = new DoublyLinkedList();\n    }\n\n    enqueue(node) {\n        this.queue.insert(new ListNode(node));\n    }\n\n    dequeue() {\n        return this.queue.popHead();\n    }\n\n    isEmpty() {\n        return this.queue.isEmpty();\n    }\n}\n\nclass DoublyLinkedList {\n    constructor(head = null) {\n        this.head = head;\n        this.tail = head;\n    }\n\n    getHead() {\n        return this.head.getData();\n    }\n\n    // Inserts an element onto the end of the list.\n    insert(listNode) {\n        if (this.tail !== null) {\n            this.tail.setNext(listNode);\n            this.tail = listNode;\n        } else {\n            this.head = listNode;\n            this.tail = listNode;\n        }\n    }\n\n    // Removes the first element from the list.\n    popHead() {\n        const listNode = this.head;\n        if (listNode !== null) {\n            this.head = this.head.getNext();\n        }\n        if (this.head === null) {\n            this.tail = null;\n        }\n        return listNode.getData();\n    }\n\n    isEmpty() {\n        return this.head === null;\n    }\n}\n\n// The node to be used in the LinkedList.\nclass ListNode {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    setNext(next) {\n        this.next = next;\n    }\n\n    getNext() {\n        return this.next;\n    }\n\n    getData() {\n        return this.data;\n    }\n}","import {getNeighbors} from './SearchHelperFunctions';\n\n// Use depth first search to find a path from 'startNode' to 'targetNode'\n// in 'grid'. The path is not guaranteed to be the shortest path. Return \n// an array of the visited nodes in order as well as an array of the path \n// discovered in reversed order.\nexport function depthFirstSearch(grid, startNode, targetNode, numRows, numCols) {\n    const visitedNodesInOrder = [];\n    const pathReversed = [];\n    startNode.isVisited = true;\n    dfs(grid, startNode, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed);\n    pathReversed.push(startNode);\n    return {visitedNodesInOrder, pathReversed};\n}\n\n// Recursive function to be used for depth first search.\nfunction dfs(grid, node, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed) {\n    if (node === targetNode) {\n        // Target node was discovered.\n        pathReversed.push(node);\n        return true;\n    }\n    const neighbors = getNeighbors(node, numRows, numCols, grid);\n    for (const neighbor of neighbors) {\n        if (!neighbor.isVisited) {\n            neighbor.isVisited = true;\n            neighbor.previousNode = node;\n            visitedNodesInOrder.push(neighbor);\n            if (dfs(grid, neighbor, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed)) {\n                pathReversed.push(neighbor);\n                return true;\n            }\n        }\n    }\n    // Target node not found.\n    return false;\n}","import {getNeighbors} from './SearchHelperFunctions'\n\nexport function aStar(grid, startNode, targetNode, numRows, numCols) {\n    const priorityQueue = new MinHeap(targetNode);\n    const visitedNodesInOrder = [];\n    const shortestPathReversed = [];\n    // Start the algorithm at the startNode.\n    startNode.distance = 0;\n    startNode.isVisited = true;\n    priorityQueue.insert(startNode, targetNode);\n    // Traverse nodes until priority queue is empty.\n    while (!priorityQueue.isEmpty()) {\n        const node = priorityQueue.pop();\n        visitedNodesInOrder.push(node);\n        if (node === targetNode) {\n            // The target Node was discovered.\n            let pathNode = node;\n            while (pathNode !== startNode) {\n                shortestPathReversed.push(pathNode);\n                pathNode = pathNode.previousNode;\n            }\n            shortestPathReversed.push(pathNode);\n            return {visitedNodesInOrder, shortestPathReversed};\n        }\n        // Get neighboring nodes and add to priority queue if unvisited.\n        const neighbors = getNeighbors(node, numRows, numCols, grid);\n        for (const neighbor of neighbors) {\n            if (!neighbor.isVisited) {\n                // Update the neighbor's distance.\n                neighbor.distance = node.distance + 1;\n                neighbor.previousNode = node;\n                priorityQueue.insert(neighbor, targetNode);\n                neighbor.isVisited = true;\n            } else {\n                // Update neighbor's distance to minimum of possible routes to that neighbor.\n                if (node.distance + 1 < neighbor.distance) {\n                    neighbor.distance = node.distance + 1;\n                    neighbor.previousNode = node;\n                    // Insert the neighbor into the queue again.\n                    priorityQueue.insert(neighbor, targetNode);\n                }\n            }\n        }\n    }\n    // The target node could not be reached.\n    return {visitedNodesInOrder, shortestPathReversed};\n}\n\n// G function for aStar that returns distance it took to get to specified node.\nfunction g(node) {\n    return node.distance;\n}\n\n// Heuristic function for aStar using Manhattan distance.\nfunction h(node, targetNode) {\n    const dx = Math.abs(targetNode.row - node.row);\n    const dy = Math.abs(targetNode.col - node.col);\n    return dx + dy;\n}\n\nfunction f(node, targetNode) {\n    return h(node, targetNode) + g(node);\n}\n\n// Used to put nodes in a priority queue based on f score (g + h). This priority queue does\n// not support reprioritizing. Instead, nodes in the queue with updated distances are inserted\n// into the queue a second time. This is okay because it won't really affect runtime.\nclass MinHeap {\n    constructor(targetNode) {\n        this.heap = [null];\n        this.targetNode = targetNode;\n    }\n\n    // Insert an element into the heap and fix the heap.\n    insert(node, targetNode) {\n        this.heap.push(node);\n        let currIndex = this.heap.length - 1;\n        let parentIndex = Math.floor(currIndex / 2);\n        while (currIndex > 1 && f(node, targetNode) <= f(this.heap[parentIndex], targetNode)) {\n            [this.heap[parentIndex], this.heap[currIndex]] = [this.heap[currIndex], this.heap[parentIndex]];\n            currIndex = parentIndex;\n            parentIndex = Math.floor(currIndex / 2);\n        }\n    }\n\n    // Pop minimum element from the front of the heap and fix the heap.\n    pop() {\n        if (this.heap.length > 2) {\n            const head = this.heap[1];\n            const tail = this.heap.splice(this.heap.length - 1)[0];\n            this.heap[1] = tail;\n\n            let currIndex = 1;\n            let leftChildIndex = currIndex * 2;\n            let rightChildIndex = currIndex * 2 + 1;\n            // While there are two child nodes, swap currNode with minChild if minChild is smaller.\n            while (this.heap[leftChildIndex] && this.heap[rightChildIndex]) {\n                let minChild = this.heap[leftChildIndex];\n                let minIndex = leftChildIndex;\n                if (f(this.heap[rightChildIndex], this.targetNode) < f(minChild, this.targetNode)) {\n                    minChild = this.heap[rightChildIndex];\n                    minIndex = rightChildIndex\n                }\n                if (f(this.heap[currIndex], this.targetNode) > f(minChild, this.targetNode)) {\n                    [this.heap[currIndex], this.heap[minIndex]] = [this.heap[minIndex], this.heap[currIndex]];\n                    currIndex = minIndex;\n                } else {\n                    break;\n                }\n                leftChildIndex = currIndex * 2;\n                rightChildIndex = currIndex * 2 + 1;\n            }\n            // If there is one child node, swap it with currNode if currNode is smaller.\n            if (this.heap[leftChildIndex] && (f(this.heap[currIndex], this.targetNode) > f(this.heap[leftChildIndex], this.targetNode))) {\n                [this.heap[currIndex], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[currIndex]];\n            } else if (this.heap[rightChildIndex] && (f(this.heap[currIndex], this.targetNode) > f(this.heap[rightChildIndex], this.targetNode))) {\n                [this.heap[currIndex], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[currIndex]];\n            }\n            return head;\n        } else if (this.heap.length === 2) {\n            return this.heap.splice(1, 1)[0];\n        } else {\n            return null;\n        }\n    }\n\n    // Returns true if the minheap is empty.\n    isEmpty() {\n        if (this.heap.length < 2) {\n            return true;\n        }\n        return false;\n    }\n}","import React, {Component} from 'react';\n\nimport Node from './Node/Node';\nimport {dijkstra} from './Search Algorithms/Dijkstra';\nimport {breadthFirstSearch} from './Search Algorithms/BreadthFirstSearch';\nimport {depthFirstSearch} from './Search Algorithms/DepthFirstSearch';\nimport {aStar} from './Search Algorithms/AStar';\n\nimport './PathfindingVisualizer.css';\n\nconst NUM_ROWS = 20\nconst NUM_COLS = Math.floor((getScreenWidth() - 40) / 28);\n\nconst START_NODE_ROW = 1;\nconst START_NODE_COL = 1;\nconst TARGET_NODE_ROW = NUM_ROWS - 2;\nconst TARGET_NODE_COL = NUM_COLS - 2;\n\nexport default class PathfindingVisualizer extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            grid: [],\n            mouseDown: false,\n        };\n    }\n\n    componentDidMount() {\n        const grid = this.createInitialGrid();\n        document.body.onmouseup = this.handleOnMouseUp.bind(this);\n        document.body.onmouseleave = this.handleOnMouseUp.bind(this);\n        this.setState({grid: grid});\n    }\n\n    render() {\n        const {grid} = this.state;\n        return (\n            <div>\n                <div className=\"search-algorithms\">\n                    <button onClick={() => this.visualizeDijkstra()} className=\"algorithm-button\">Dijkstra's Algorithm</button>\n                    <button onClick={() => this.visualizeBreadthFirstSearch()} className=\"algorithm-button\">Breadth First Search</button>\n                    <button onClick={() => this.visualizeDepthFirstSearch()} className=\"algorithm-button\">Depth First Search</button>\n                    <button onClick={() => this.visualizeAStar()} className=\"algorithm-button\">A* Search</button>\n                </div>\n                <div className=\"grid-functions\">\n                    <button onClick={this.clearWalls.bind(this)} className=\"grid-function-button\">Clear Walls</button>\n                    <button onClick={this.clearPath.bind(this)} className=\"grid-function-button\">Clear Path</button>\n                </div>\n                {this.displayGrid(grid)}\n                <div className=\"credits\">\n                    <a target=\"_blank\" href=\"https://icons8.com/icon/62234/launch\">Launch</a> icon by <a target=\"_blank\" href=\"https://icons8.com\">Icons8</a>\n                    <a target=\"_blank\" href=\"https://icons8.com/icon/100900/empty-flag\">Empty Flag</a> icon by <a target=\"_blank\" href=\"https://icons8.com\">Icons8</a>\n                    <a target=\"_blank\" href=\"https://icons8.com/icon/118838/vertical-line\">Vertical Line</a> icon by <a target=\"_blank\" href=\"https://icons8.com\">Icons8</a>\n                </div>\n            </div>\n        );\n    }\n\n    visualizeDijkstra() {\n        let grid = this.copyGrid();\n        this.resetNodes(grid);\n        this.setState({grid: grid}, () => {\n            grid = this.copyGrid();\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\n            const targetNode = grid[TARGET_NODE_ROW][TARGET_NODE_COL];\n            const {visitedNodesInOrder, shortestPathReversed} = dijkstra(grid, startNode, targetNode, NUM_ROWS, NUM_COLS);\n            this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n        });\n    }\n\n    visualizeBreadthFirstSearch() {\n        let grid = this.copyGrid();\n        this.resetNodes(grid);\n        this.setState({grid: grid}, () => {\n            grid = this.copyGrid();\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\n            const targetNode = grid[TARGET_NODE_ROW][TARGET_NODE_COL];\n            const {visitedNodesInOrder, shortestPathReversed} = breadthFirstSearch(grid, startNode, targetNode, NUM_ROWS, NUM_COLS);\n            this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n        });\n    }\n\n    visualizeDepthFirstSearch() {\n        let grid = this.copyGrid();\n        this.resetNodes(grid);\n        this.setState({grid: grid}, () => {\n            grid = this.copyGrid();\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\n            const targetNode = grid[TARGET_NODE_ROW][TARGET_NODE_COL];\n            const {visitedNodesInOrder, pathReversed} = depthFirstSearch(grid, startNode, targetNode, NUM_ROWS, NUM_COLS);\n            this.animateSearch(visitedNodesInOrder, pathReversed);\n        });\n    }\n\n    visualizeAStar() {\n        let grid = this.copyGrid();\n        this.resetNodes(grid);\n        this.setState({grid: grid}, () => {\n            grid = this.copyGrid();\n            const startNode = grid[START_NODE_ROW][START_NODE_COL];\n            const targetNode = grid[TARGET_NODE_ROW][TARGET_NODE_COL];\n            const {visitedNodesInOrder, shortestPathReversed} = aStar(grid, startNode, targetNode, NUM_ROWS, NUM_COLS);\n            this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n        });\n    }\n\n    animateSearch(visitedNodesInOrder, pathReversed) {\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\n            setTimeout(() => {\n                const node = visitedNodesInOrder[i];\n                // Start path animation after last visited node.\n                if (i === visitedNodesInOrder.length - 1) {\n                    this.animatePath(pathReversed);\n                } else {\n                    if (!node.isStart && !node.isTarget) {\n                        // Normally shouldn't do this, but had to to optimize performance.\n                        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n                    }\n                }\n            }, 5 * i);\n        }\n    }\n\n    animatePath(pathReversed) {\n        const lines = this.pathToLines(pathReversed);\n        let startRow = START_NODE_ROW;\n        let startCol = START_NODE_COL;\n        for (let i = pathReversed.length - 1; i >= 0; i--) {\n            startRow = pathReversed[i].row;\n            startCol = pathReversed[i].col;\n            setTimeout(\n                () => this.moveRocketShip(pathReversed, lines, i),\n                3000 * ((pathReversed.length - i) / pathReversed.length)\n            );\n        }\n    }\n\n    moveRocketShip(pathReversed, lines, i) {\n        const node = pathReversed[i];\n            if (!node.isStart) {\n                const prevNode = pathReversed[i+1];\n                const grid = this.copyGrid();\n                grid[prevNode.row][prevNode.col].isStart = false;\n                grid[prevNode.row][prevNode.col].isPath = true;\n                grid[prevNode.row][prevNode.col].direction = lines[i + 1];\n                grid[node.row][node.col].isStart = true;\n                if (grid[node.row][node.col].isTarget) {\n                    grid[node.row][node.col].isTargetReached = true;\n                } \n                this.setState({grid: grid});\n            }\n    }\n\n    // Returns an array of lines, given a path of nodes.\n    pathToLines(pathReversed) {\n        const lines = [];\n        const directions = [];\n        directions.push('none');\n        for (let i = 1; i < pathReversed.length; i++) {\n            let prevNode = pathReversed[i-1];\n            let currNode = pathReversed[i];\n            let dRow = prevNode.row - currNode.row;\n            let dCol = currNode.col - prevNode.col;\n            const direction = \n                dCol === 1 ? 'right':\n                dCol === -1 ? 'left':\n                dRow === 1 ? 'up':\n                dRow === -1 ? 'down':\n                '';\n            directions.push(direction);\n            const line =\n                direction === 'right' && directions[i-1] === 'none' ? 'horizontal':\n                direction === 'right' && directions[i-1] === 'right' ? 'horizontal':\n                direction === 'right' && directions[i-1] === 'up' ? 'ul':\n                direction === 'right' && directions[i-1] === 'down' ? 'bl':\n                direction === 'left' && directions[i-1] === 'none' ? 'horizontal':\n                direction === 'left' && directions[i-1] === 'left' ? 'horizontal':\n                direction === 'left' && directions[i-1] === 'up' ? 'ur':\n                direction === 'left' && directions[i-1] === 'down' ? 'br':\n                direction === 'up' && directions[i-1] === 'none' ? 'vertical':\n                direction === 'up' && directions[i-1] === 'up' ? 'vertical':\n                direction === 'up' && directions[i-1] === 'left' ? 'bl':\n                direction === 'up' && directions[i-1] === 'right' ? 'br':\n                direction === 'down' && directions[i-1] === 'none' ? 'vertical':\n                direction === 'down' && directions[i-1] === 'down' ? 'vertical':\n                direction === 'down' && directions[i-1] === 'left' ? 'ul':\n                direction === 'down' && directions[i-1] === 'right' ? 'ur':\n                '';\n            lines.push(line);\n        }\n        lines.push('landing-pad');\n        return lines;\n    }\n\n    // Handles onMouseDown event on node at given row and column.\n    handleOnMouseDown(row, col) {\n        const grid = this.copyGrid();\n        const node = grid[row][col];\n        node.isWall = !node.isWall;\n        this.setState({grid: grid, mouseDown: true});\n    }\n\n    handleOnMouseUp() {\n        if (this.state.mouseDown === true) {\n            this.setState({mouseDown: false});\n        }\n    }\n\n    handleOnMouseEnter(row, col) {\n        if (this.state.mouseDown === true) {\n            const grid = this.copyGrid();\n            const node = grid[row][col];\n            node.isWall = !node.isWall;\n            this.setState({grid: grid})\n        }\n    }\n\n    // Create a 2D array of node objects.\n    createInitialGrid() {\n        const grid = [];\n        for (let row = 0; row < NUM_ROWS; row++) {\n            const currentRow = [];\n            for (let col = 0; col < NUM_COLS; col++) {\n                const currNode = new NodeObj(col, row);\n                currentRow.push(currNode);\n            }\n            grid.push(currentRow);\n        }\n        return grid;\n    }\n\n    // Map the grid to Node components that are displayed.\n    displayGrid(nodes) {\n        return  (\n            <div className=\"grid\">\n                {nodes.map((row, rowIndex) => {\n                    return <div className=\"row\" key={rowIndex}>\n                        {row.map((node, nodeIndex) => {\n                            return (\n                                <Node \n                                draggable=\"false\"\n                                key={nodeIndex}\n                                isStart={node.isStart} \n                                isTarget={node.isTarget}\n                                isWall={node.isWall}\n                                isVisited={node.isVisited}\n                                isPath={node.isPath}\n                                row={node.row}\n                                col={node.col}\n                                direction={node.direction}\n                                isTargetReached={node.isTargetReached}\n                                handleOnMouseDown={this.handleOnMouseDown.bind(this)}\n                                handleOnMouseUp={this.handleOnMouseUp.bind(this)}\n                                handleOnMouseEnter={this.handleOnMouseEnter.bind(this)}>\n                                </Node>);\n                        })}\n                    </div>\n                })}\n            </div>\n        );\n    }\n\n    resetNodes(grid) {\n        for (const row of grid) {\n            for (const node of row) {\n                // We have to reset isVisited, and isPath of nodes the same way we set them.\n                if (!node.isWall && !node.isStart && !node.isTarget) {\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\n                }\n                node.isVisited = false;\n                node.isPath = false;\n                node.previousNode = null;\n                node.distance = Infinity;\n                node.isStart = node.row === START_NODE_ROW && node.col === START_NODE_COL;\n                node.isTarget = node.row === TARGET_NODE_ROW && node.col === TARGET_NODE_COL;\n                node.isTargetReached = false;\n            }\n        }\n    }\n\n    clearPath() {\n        const grid = this.copyGrid();\n        this.resetNodes(grid);\n        this.setState({grid: grid});\n    }\n\n    clearWalls() {\n        const grid = this.copyGrid();\n        for (const row of grid) {\n            for (const node of row) {\n                if (node.isWall) {\n                    node.isWall = false;\n                }\n            }\n        }\n        this.setState({grid: grid});\n    }\n\n    copyGrid() {\n        const grid = this.state.grid;\n        const copiedGrid = [];\n        for (const row of grid) {\n            const copiedRow = row.map((node) => {\n                const copiedNode = Object.assign({}, node);\n                return copiedNode;\n            })\n            copiedGrid.push(copiedRow);\n        }\n        return copiedGrid;\n    }\n}\n\n// Node object constructor.\nfunction NodeObj(col, row) {\n    this.col = col;\n    this.row = row;\n    this.isStart = row === START_NODE_ROW && col === START_NODE_COL;\n    this.isTarget = row === TARGET_NODE_ROW && col === TARGET_NODE_COL;\n    this.isVisited = false;\n    this.isWall = false;\n    // Distance from start node.\n    this.distance = Infinity;\n    // Previous node used to trace path.\n    this.previousNode = null;\n    this.direction = null;\n    this.isTargetReached = false;\n}\n\n// Function to get the width of the browser window.\nfunction getScreenWidth() {\n    return Math.max(\n      document.body.scrollWidth,\n      document.documentElement.scrollWidth,\n      document.body.offsetWidth,\n      document.documentElement.offsetWidth,\n      document.documentElement.clientWidth\n    );\n  }","import MinHeap from '../Data Structures/MinHeap';\nimport {getNeighbors} from './SearchHelperFunctions';\n\n// Use dijkstra's algorithm to find the shortest path from 'startNode' to \n//'targetNode' in 'grid'. Return an array of the visited nodes in order as \n// well as the shortest path in reversed order.\nexport function dijkstra (grid, startNode, targetNode, numRows, numCols) {\n    startNode.distance = 0;\n    const priorityQueue = new MinHeap();\n    const visitedNodesInOrder = [];\n    const shortestPathReversed = [];\n    priorityQueue.insert(startNode);\n    while (!priorityQueue.isEmpty()) {\n        const node = priorityQueue.pop();\n        visitedNodesInOrder.push(node);\n        if (node === targetNode) {\n            // The target node was discovered.\n            let pathNode = node;\n            while (pathNode !== startNode) {\n                shortestPathReversed.push(pathNode);\n                pathNode = pathNode.previousNode;\n            }\n            shortestPathReversed.push(pathNode);\n            return {visitedNodesInOrder, shortestPathReversed};\n        }\n        const neighbors = getNeighbors(node, numRows, numCols, grid);\n        for (const neighbor of neighbors) {\n            // Only update distance of neighbors if path results in lower distance.\n            if (node.distance + 1 < neighbor.distance) {\n                neighbor.distance = node.distance + 1;\n                neighbor.previousNode = node;\n            }\n            // Only add unvisited nodes to the priority queue.\n            if (!neighbor.isVisited) {\n                neighbor.isVisited = true;\n                priorityQueue.insert(neighbor);\n            }\n            //priorityQueue.insert(neighbor);\n        }\n    }    \n    // The target node could not be reached.\n    return {visitedNodesInOrder, shortestPathReversed};\n}","import Queue from '../Data Structures/Queue';\nimport { getNeighbors } from './SearchHelperFunctions';\n\n// Use breadth first search to find the shortest path from 'startNode' to 'targetNode'\n// in 'grid'. Return an array of the visited nodes in order as well as an array\n// of the shortest path in reversed order.\nexport function breadthFirstSearch(grid, startNode, targetNode, numRows, numCols) {\n    const visitedNodesInOrder = [];\n    const shortestPathReversed = [];\n    const q = new Queue();\n    q.enqueue(startNode);\n    startNode.isVisited = true;\n    while (!q.isEmpty()) {\n        const node = q.dequeue();\n        visitedNodesInOrder.push(node);\n        if (node === targetNode) {\n            // The target node was discovered.\n            let pathNode = node;\n            while (pathNode !== startNode) {\n                shortestPathReversed.push(pathNode);\n                pathNode = pathNode.previousNode;\n            }\n            shortestPathReversed.push(pathNode);\n            return {visitedNodesInOrder, shortestPathReversed};\n        }\n        const neighbors = getNeighbors(node, numRows, numCols, grid);\n        for (const neighbor of neighbors) {\n            if (!neighbor.isVisited) {\n                q.enqueue(neighbor);\n                neighbor.isVisited = true;\n                neighbor.previousNode = node;\n            }\n        }\n    }\n    // The target node could not be reached.\n    return {visitedNodesInOrder, shortestPathReversed};\n}\n\n// Add walls that can be placed.\n// Add bridges that take you from one node to another in shorter time.\n// Add weights that slow you down.","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}