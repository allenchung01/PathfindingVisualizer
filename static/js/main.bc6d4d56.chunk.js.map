{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/Buttons/DropdownMenu/DropdownMenu.jsx","PathfindingVisualizer/NavigationBar/NavigationBar.jsx","PathfindingVisualizer/Images/paintbrushes.svg","PathfindingVisualizer/Hints/Hint.jsx","PathfindingVisualizer/Buttons/DrawToggle/DrawToggle.jsx","PathfindingVisualizer/Images/weight-plates.svg","PathfindingVisualizer/Buttons/Slider/Slider.js","PathfindingVisualizer/AlgorithmTitle/AlgorithmTitle.jsx","PathfindingVisualizer/Data Structures/MinHeap.js","PathfindingVisualizer/Search Algorithms/SearchHelperFunctions.js","PathfindingVisualizer/Search Algorithms/Dijkstra.js","PathfindingVisualizer/Data Structures/Queue.js","PathfindingVisualizer/Search Algorithms/BreadthFirstSearch.js","PathfindingVisualizer/Search Algorithms/DepthFirstSearch.js","PathfindingVisualizer/Search Algorithms/AStar.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","setState","isWall","handleOnMouseDown","row","col","handleOnMouseUp","handleOnMouseEnter","nextProps","nextState","isVisited","isPath","isStart","isTargetReached","isWeight","isTarget","direction","nodeType","onDragStart","e","preventDefault","className","onMouseDown","bind","onMouseUp","onMouseEnter","id","Component","DropdownMenu","useState","dropdownIsVisible","setDropdownIsVisible","title","onClick","children","map","child","index","NavigationBar","Hint","message","WALLS","WEIGHTS","Toggle","selected","setSelected","isHintDisplayed","setIsHintDisplayed","setDrawMode","toggleHint","src","brushesImg","width","height","onMouseLeave","Slider","value","setValue","weightImg","type","min","max","onChange","target","valueAsNumber","AlgorithmTitle","algorithm","infoIsDisplayed","setInfoIsDisplayed","dijkstraInfo","concat","bfsInfo","dfsInfo","aStarInfo","getInfo","MinHeap","heap","node","push","currIndex","length","parentIndex","Math","floor","distance","head","tail","splice","leftChildIndex","rightChildIndex","minChild","minIndex","getNeighbors","numRows","numCols","grid","neighbors","isSafe","dijkstra","startNode","targetNode","weightValue","priorityQueue","visitedNodesInOrder","shortestPathReversed","insert","isEmpty","pop","pathNode","previousNode","neighbor","weight","Queue","queue","DoublyLinkedList","ListNode","popHead","getData","listNode","setNext","getNext","data","next","breadthFirstSearch","q","enqueue","dequeue","depthFirstSearch","pathReversed","dfs","aStar","f","abs","h","g","NUM_ROWS","window","innerHeight","NUM_COLS","document","body","scrollWidth","documentElement","offsetWidth","clientWidth","TARGET_NODE_ROW","TARGET_NODE_COL","DIJKSTRA","BFS","DFS","ASTAR","PathfindingVisualizer","startNodeRow","startNodeCol","targetNodeRow","targetNodeCol","mouseDown","drawMode","movingStart","movingTarget","movingLaunchPad","launchPadRow","launchPadCol","createInitialGrid","onmouseup","onmouseleave","visualize","clearPath","clearWalls","clearWeights","style","marginRight","mode","setWeightValue","displayGrid","visualizeDijkstra","visualizeBreadthFirstSearch","visualizeDepthFirstSearch","visualizeAStar","copyGrid","lines","pathToLines","i","resetNodes","animateSearch","setTimeout","animatePath","element","getElementById","classList","remove","add","moveRocketShip","prevNode","directions","currNode","dRow","dCol","line","node_","prevTarget","redrawPath","prevLaunchPad","currentRow","NodeObj","nodes","rowIndex","nodeIndex","draggable","Infinity","copiedGrid","copiedRow","Object","assign","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.bc6d4d56.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n  }\n\n  toggleWall() {\n    this.setState({ isWall: !this.props.isWall });\n  }\n\n  handleOnMouseDown() {\n    this.props.handleOnMouseDown(this.props.row, this.props.col);\n  }\n\n  handleOnMouseUp() {\n    this.props.handleOnMouseUp();\n  }\n\n  handleOnMouseEnter() {\n    this.props.handleOnMouseEnter(this.props.row, this.props.col);\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    if (\n      nextProps.isWall !== this.props.isWall ||\n      nextProps.isVisited !== this.props.isVisited ||\n      nextProps.isPath !== this.props.isPath ||\n      nextProps.isStart !== this.props.isStart ||\n      nextProps.isTargetReached !== this.props.isTargetReached ||\n      nextProps.isWeight !== this.props.isWeight ||\n      nextProps.isTarget !== this.props.isTarget ||\n      nextProps.direction !== this.props.direction\n    ) {\n      return true;\n    }\n    return true;\n  }\n\n  render() {\n    const {\n      isTarget,\n      isStart,\n      isWall,\n      isWeight,\n      isVisited,\n      isPath,\n      row,\n      col,\n      direction,\n      isTargetReached,\n    } = this.props;\n    const nodeType = isTargetReached\n      ? \"node-target-reached\"\n      : isPath && direction == \"landing-pad\"\n      ? \"node-path-landing-pad\"\n      : isTarget\n      ? \"node-target\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : isWeight\n      ? \"node-weight\"\n      : isPath && direction == \"horizontal\"\n      ? \"node-path-horizontal\"\n      : isPath && direction == \"vertical\"\n      ? \"node-path-vertical\"\n      : isPath && direction == \"ul\"\n      ? \"node-path-ul\"\n      : isPath && direction == \"ur\"\n      ? \"node-path-ur\"\n      : isPath && direction == \"bl\"\n      ? \"node-path-bl\"\n      : isPath && direction == \"br\"\n      ? \"node-path-br\"\n      : \"\";\n    return (\n      <div\n        onDragStart={(e) => {\n          e.preventDefault();\n        }}\n        className=\"node-bounds\"\n        onMouseDown={this.handleOnMouseDown.bind(this)}\n        onMouseUp={this.handleOnMouseUp.bind(this)}\n        onMouseEnter={this.handleOnMouseEnter.bind(this)}\n      >\n        <div\n          className={`node ${nodeType} ${isVisited ? \"visited\" : \"unvisited\"}`}\n          id={`node-${row}-${col}`}\n        ></div>\n      </div>\n    );\n  }\n}\n","import React, { useState } from \"react\";\nimport \"./DropdownMenu.css\";\n\nexport default function DropdownMenu(props) {\n  const [dropdownIsVisible, setDropdownIsVisible] = useState(false);\n  const { title } = props;\n\n  const onClick = () => {\n    setDropdownIsVisible(!dropdownIsVisible);\n  };\n\n  return (\n    <div className=\"dropdown-menu\">\n      <button id=\"button\" onClick={onClick}>\n        {title}\n      </button>\n      {dropdownIsVisible ? (\n        <ul onClick={() => setDropdownIsVisible(false)}>\n          {props.children.map((child, index) => {\n            return <li key={index}>{child}</li>;\n          })}\n        </ul>\n      ) : null}\n    </div>\n  );\n}\n","import React from \"react\";\nimport \"./NavigationBar.css\";\n\nexport default function NavigationBar(props) {\n  return <div className=\"navigation-bar\">{props.children}</div>;\n}\n","export default __webpack_public_path__ + \"static/media/paintbrushes.8ab87ecc.svg\";","import React from \"react\";\nimport \"./Hint.css\";\n\nexport default function Hint(props) {\n  const { message } = props;\n  return <div className=\"hint-container\">{message}</div>;\n}\n","import React, { useState } from \"react\";\nimport \"./DrawToggle.css\";\nimport brushesImg from \"../../Images/paintbrushes.svg\";\nimport Hint from \"../../Hints/Hint\";\n\nconst WALLS = \"Walls\";\nconst WEIGHTS = \"Weights\";\n\nexport default function Toggle(props) {\n  const [selected, setSelected] = useState(WALLS);\n  const [isHintDisplayed, setIsHintDisplayed] = useState(false);\n  const { setDrawMode } = props;\n\n  const toggleHint = () => {\n    setIsHintDisplayed(!isHintDisplayed);\n  };\n\n  return (\n    <div id=\"container\">\n      {isHintDisplayed ? <Hint message=\"Draw Mode\" /> : null}\n      <img\n        id=\"brushes-img\"\n        src={brushesImg}\n        width=\"14\"\n        height=\"14\"\n        onMouseEnter={toggleHint}\n        onMouseLeave={toggleHint}\n      />\n      <div className=\"toggle\">\n        <button\n          onClick={() => {\n            setSelected(WALLS);\n            setDrawMode(WALLS);\n          }}\n          className={selected === WALLS ? \"selected\" : \"unselected\"}\n        >\n          Walls\n        </button>\n        <button\n          onClick={() => {\n            setSelected(WEIGHTS);\n            setDrawMode(WEIGHTS);\n          }}\n          className={selected === WEIGHTS ? \"selected\" : \"unselected\"}\n        >\n          Weights\n        </button>\n      </div>\n    </div>\n  );\n}\n","export default __webpack_public_path__ + \"static/media/weight-plates.4761408d.svg\";","import React, { useState } from \"react\";\nimport \"./Slider.css\";\nimport weightImg from \"../../Images/weight-plates.svg\";\nimport Hint from \"../../Hints/Hint\";\n\nexport default function Slider(props) {\n  const [isHintDisplayed, setIsHintDisplayed] = useState(false);\n  const { value, setValue } = props;\n\n  const toggleHint = () => {\n    setIsHintDisplayed(!isHintDisplayed);\n  };\n\n  return (\n    <div id=\"weight-slider-section\">\n      {isHintDisplayed ? <Hint message=\"Weight Value\" /> : null}\n      <img\n        id=\"weightImg\"\n        src={weightImg}\n        width=\"14\"\n        height=\"14\"\n        onMouseEnter={toggleHint}\n        onMouseLeave={toggleHint}\n      />\n      <div className=\"slider-container\">\n        <input\n          className=\"slider\"\n          type=\"range\"\n          min={1}\n          max={20}\n          value={value}\n          onChange={(e) => {\n            setValue(e.target.valueAsNumber);\n          }}\n        />\n        <p id=\"value\">{value}</p>\n      </div>\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport \"./AlgorithmTitle.css\";\n\nconst DIJKSTRA = \"Dijkstra\";\nconst BFS = \"BFS\";\nconst DFS = \"DFS\";\nconst ASTAR = \"A*\";\n\nexport function AlgorithmTitle(props) {\n  const { algorithm } = props;\n  const [infoIsDisplayed, setInfoIsDisplayed] = useState(false);\n\n  const dijkstraInfo =\n    \"Dijkstra's Algorithm finds the shortest path between between two given nodes.\".concat(\n      \" It does this by taking into account the weights of edges and using a priority queue that sorts neighboring nodes by distance.\".concat(\n        \" It then visits those nodes in ascending order of distance.\".concat(\n          \" In this visualization, nodes have a distance of 1 and weights have a distance of 5.\"\n        )\n      )\n    );\n  const bfsInfo =\n    \"Breadth First Search finds the shortest path between between two given nodes.\".concat(\n      \" It starts by adding neighboring nodes to a queue.\".concat(\n        \" It then pops the first node from the queue, visits it, and adds its neighbors to the queue.\"\n          .concat(\" This process repeats until the target node is reached.\")\n          .concat(\" Breadth First Search does not take weights into account.\")\n      )\n    );\n  const dfsInfo =\n    \"Depth First Search finds a path between between two given nodes, but it does not guarentee the shortest path.\".concat(\n      \" It does this by recursively visiting neighboring nodes instead of using a queue.\".concat(\n        \" This means that deep nodes will be reached before nearby nodes.\".concat(\n          \" Depth First Search does not take weights into account.\"\n        )\n      )\n    );\n  const aStarInfo =\n    \"A* Search Algorithm finds the shortest path between between two given nodes.\".concat(\n      \" It also has knowledge of where the end node is beforehand.\".concat(\n        \" It uses a queue similar to Dijkstra's algorithm, but instead assigns scores to neighboring nodes based on distance to the node along with estimated distance to the target node.\".concat(\n          \" In this visualization, nodes have a distance of 1 and weights have a distance of 5.\"\n        )\n      )\n    );\n\n  const getInfo = (algorithm) => {\n    switch (algorithm) {\n      case DIJKSTRA:\n        return dijkstraInfo;\n      case BFS:\n        return bfsInfo;\n      case DFS:\n        return dfsInfo;\n      case ASTAR:\n        return aStarInfo;\n    }\n  };\n\n  return (\n    <div id=\"bottom-left-fixed\">\n      <h1 id=\"big-algorithm-name\">{algorithm}</h1>\n      <div\n        onMouseEnter={() => setInfoIsDisplayed(true)}\n        onMouseLeave={() => setInfoIsDisplayed(false)}\n        className=\"info-icon\"\n      />\n      {infoIsDisplayed ? (\n        <p className=\"info-popup\">{getInfo(algorithm)}</p>\n      ) : null}\n    </div>\n  );\n}\n","// Used to put nodes in a priority queue based on distance.\nexport default class MinHeap {\n    constructor() {\n        this.heap = [null];\n    }\n\n    // Insert an element into the heap and fix the heap.\n    insert(node) {\n        this.heap.push(node);\n        let currIndex = this.heap.length - 1;\n        let parentIndex = Math.floor(currIndex / 2);\n        while (currIndex > 1 && node.distance < this.heap[parentIndex].distance) {\n            [this.heap[parentIndex], this.heap[currIndex]] = [this.heap[currIndex], this.heap[parentIndex]];\n            currIndex = parentIndex;\n            parentIndex = Math.floor(currIndex / 2);\n        }\n    }\n\n    // Pop minimum element from the front of the heap and fix the heap.\n    pop() {\n        if (this.heap.length > 2) {\n            const head = this.heap[1];\n            const tail = this.heap.splice(this.heap.length - 1)[0];\n            this.heap[1] = tail;\n\n            let currIndex = 1;\n            let leftChildIndex = currIndex * 2;\n            let rightChildIndex = currIndex * 2 + 1;\n            // While there are two child nodes, swap currNode with minChild if minChild is smaller.\n            while (this.heap[leftChildIndex] && this.heap[rightChildIndex]) {\n                let minChild = this.heap[leftChildIndex];\n                let minIndex = leftChildIndex;\n                if (this.heap[rightChildIndex].distance < minChild.distance) {\n                    minChild = this.heap[rightChildIndex];\n                    minIndex = rightChildIndex\n                }\n                if (this.heap[currIndex].distance > minChild.distance) {\n                    [this.heap[currIndex], this.heap[minIndex]] = [this.heap[minIndex], this.heap[currIndex]];\n                    currIndex = minIndex;\n                } else {\n                    break;\n                }\n                leftChildIndex = currIndex * 2;\n                rightChildIndex = currIndex * 2 + 1;\n            }\n            // If there is one child node, swap it with currNode if currNode is smaller.\n            if (this.heap[leftChildIndex] && (this.heap[currIndex].distance > this.heap[leftChildIndex].distance)) {\n                [this.heap[currIndex], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[currIndex]];\n            } else if (this.heap[rightChildIndex] && (this.heap[currIndex].distance > this.heap[rightChildIndex].distance)) {\n                [this.heap[currIndex], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[currIndex]];\n            }\n            return head;\n        } else if (this.heap.length === 2) {\n            return this.heap.splice(1, 1)[0];\n        } else {\n            return null;\n        }\n    }\n\n    // Returns true if the minheap is empty.\n    isEmpty() {\n        if (this.heap.length < 2) {\n            return true;\n        }\n        return false;\n    }\n}","// Returns ALL neighbors of 'node', visited or not. Neighbors\n// cannot have walls.\nexport function getNeighbors(node, numRows, numCols, grid) {\n    const {row, col} = node;\n    const neighbors = [];\n    // North neighbor.\n    if (isSafe(row + 1, col, numRows, numCols) && !grid[row + 1][col].isWall) {\n        neighbors.push(grid[row + 1][col]);\n    }\n    // South neighbor.\n    if (isSafe(row - 1, col, numRows, numCols) && !grid[row - 1][col].isWall) {\n        neighbors.push(grid[row - 1][col]);\n    }\n    // East neighbor.\n    if (isSafe(row, col + 1, numRows, numCols) && !grid[row][col + 1].isWall) {\n        neighbors.push(grid[row][col + 1]);\n    }\n    // West neighbor.\n    if (isSafe(row, col - 1, numRows, numCols) && !grid[row][col - 1].isWall) {\n        neighbors.push(grid[row][col - 1]);\n    }\n    return neighbors;\n}\n\n// Returns true if row and col are on the board.\nfunction isSafe(row, col, numRows, numCols) {\n    if (row >= 0 && row < numRows &&\n        col >= 0 && col < numCols) {\n        return true;\n    }\n    return false;\n}","import MinHeap from \"../Data Structures/MinHeap\";\nimport { getNeighbors } from \"./SearchHelperFunctions\";\n\n// Use dijkstra's algorithm to find the shortest path from 'startNode' to\n//'targetNode' in 'grid'. Return an array of the visited nodes in order as\n// well as the shortest path in reversed order.\nexport function dijkstra(\n  grid,\n  startNode,\n  targetNode,\n  numRows,\n  numCols,\n  weightValue\n) {\n  startNode.distance = 0;\n  const priorityQueue = new MinHeap();\n  const visitedNodesInOrder = [];\n  const shortestPathReversed = [];\n  priorityQueue.insert(startNode);\n  while (!priorityQueue.isEmpty()) {\n    const node = priorityQueue.pop();\n    visitedNodesInOrder.push(node);\n    if (node === targetNode) {\n      // The target node was discovered.\n      let pathNode = node;\n      while (pathNode !== startNode) {\n        shortestPathReversed.push(pathNode);\n        pathNode = pathNode.previousNode;\n      }\n      shortestPathReversed.push(pathNode);\n      return { visitedNodesInOrder, shortestPathReversed };\n    }\n    const neighbors = getNeighbors(node, numRows, numCols, grid);\n    for (const neighbor of neighbors) {\n      const weight = neighbor.isWeight ? weightValue : 1;\n      // Only update distance of neighbors if path results in lower distance.\n      if (node.distance + weight < neighbor.distance) {\n        neighbor.distance = node.distance + weight;\n        neighbor.previousNode = node;\n      }\n      // Only add unvisited nodes to the priority queue.\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        priorityQueue.insert(neighbor);\n      }\n      //priorityQueue.insert(neighbor);\n    }\n  }\n  // The target node could not be reached.\n  return { visitedNodesInOrder, shortestPathReversed };\n}\n","// Used as a first-in, first-out datastructure.\nexport default class Queue {\n    constructor() {\n        this.queue = new DoublyLinkedList();\n    }\n\n    enqueue(node) {\n        this.queue.insert(new ListNode(node));\n    }\n\n    dequeue() {\n        return this.queue.popHead();\n    }\n\n    isEmpty() {\n        return this.queue.isEmpty();\n    }\n}\n\nclass DoublyLinkedList {\n    constructor(head = null) {\n        this.head = head;\n        this.tail = head;\n    }\n\n    getHead() {\n        return this.head.getData();\n    }\n\n    // Inserts an element onto the end of the list.\n    insert(listNode) {\n        if (this.tail !== null) {\n            this.tail.setNext(listNode);\n            this.tail = listNode;\n        } else {\n            this.head = listNode;\n            this.tail = listNode;\n        }\n    }\n\n    // Removes the first element from the list.\n    popHead() {\n        const listNode = this.head;\n        if (listNode !== null) {\n            this.head = this.head.getNext();\n        }\n        if (this.head === null) {\n            this.tail = null;\n        }\n        return listNode.getData();\n    }\n\n    isEmpty() {\n        return this.head === null;\n    }\n}\n\n// The node to be used in the LinkedList.\nclass ListNode {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    setNext(next) {\n        this.next = next;\n    }\n\n    getNext() {\n        return this.next;\n    }\n\n    getData() {\n        return this.data;\n    }\n}","import Queue from '../Data Structures/Queue';\nimport { getNeighbors } from './SearchHelperFunctions';\n\n// Use breadth first search to find the shortest path from 'startNode' to 'targetNode'\n// in 'grid'. Return an array of the visited nodes in order as well as an array\n// of the shortest path in reversed order.\nexport function breadthFirstSearch(grid, startNode, targetNode, numRows, numCols) {\n    const visitedNodesInOrder = [];\n    const shortestPathReversed = [];\n    const q = new Queue();\n    q.enqueue(startNode);\n    startNode.isVisited = true;\n    while (!q.isEmpty()) {\n        const node = q.dequeue();\n        visitedNodesInOrder.push(node);\n        if (node === targetNode) {\n            // The target node was discovered.\n            let pathNode = node;\n            while (pathNode !== startNode) {\n                shortestPathReversed.push(pathNode);\n                pathNode = pathNode.previousNode;\n            }\n            shortestPathReversed.push(pathNode);\n            return {visitedNodesInOrder, shortestPathReversed};\n        }\n        const neighbors = getNeighbors(node, numRows, numCols, grid);\n        for (const neighbor of neighbors) {\n            if (!neighbor.isVisited) {\n                q.enqueue(neighbor);\n                neighbor.isVisited = true;\n                neighbor.previousNode = node;\n            }\n        }\n    }\n    // The target node could not be reached.\n    return {visitedNodesInOrder, shortestPathReversed};\n}\n\n// Add walls that can be placed.\n// Add bridges that take you from one node to another in shorter time.\n// Add weights that slow you down.","import {getNeighbors} from './SearchHelperFunctions';\n\n// Use depth first search to find a path from 'startNode' to 'targetNode'\n// in 'grid'. The path is not guaranteed to be the shortest path. Return \n// an array of the visited nodes in order as well as an array of the path \n// discovered in reversed order.\nexport function depthFirstSearch(grid, startNode, targetNode, numRows, numCols) {\n    const visitedNodesInOrder = [];\n    const pathReversed = [];\n    startNode.isVisited = true;\n    dfs(grid, startNode, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed);\n    pathReversed.push(startNode);\n    return {visitedNodesInOrder, pathReversed};\n}\n\n// Recursive function to be used for depth first search.\nfunction dfs(grid, node, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed) {\n    if (node === targetNode) {\n        // Target node was discovered.\n        pathReversed.push(node);\n        return true;\n    }\n    const neighbors = getNeighbors(node, numRows, numCols, grid);\n    for (const neighbor of neighbors) {\n        if (!neighbor.isVisited) {\n            neighbor.isVisited = true;\n            neighbor.previousNode = node;\n            visitedNodesInOrder.push(neighbor);\n            if (dfs(grid, neighbor, targetNode, numRows, numCols, visitedNodesInOrder, pathReversed)) {\n                pathReversed.push(neighbor);\n                return true;\n            }\n        }\n    }\n    // Target node not found.\n    return false;\n}","import { getNeighbors } from \"./SearchHelperFunctions\";\n\nexport function aStar(\n  grid,\n  startNode,\n  targetNode,\n  numRows,\n  numCols,\n  weightValue\n) {\n  const priorityQueue = new MinHeap(targetNode);\n  const visitedNodesInOrder = [];\n  const shortestPathReversed = [];\n  // Start the algorithm at the startNode.\n  startNode.distance = 0;\n  startNode.isVisited = true;\n  priorityQueue.insert(startNode, targetNode);\n  // Traverse nodes until priority queue is empty.\n  while (!priorityQueue.isEmpty()) {\n    const node = priorityQueue.pop();\n    visitedNodesInOrder.push(node);\n    if (node === targetNode) {\n      // The target Node was discovered.\n      let pathNode = node;\n      while (pathNode !== startNode) {\n        shortestPathReversed.push(pathNode);\n        pathNode = pathNode.previousNode;\n      }\n      shortestPathReversed.push(pathNode);\n      return { visitedNodesInOrder, shortestPathReversed };\n    }\n    // Get neighboring nodes and add to priority queue if unvisited.\n    const neighbors = getNeighbors(node, numRows, numCols, grid);\n    for (const neighbor of neighbors) {\n      const weight = neighbor.isWeight ? weightValue : 1;\n      if (!neighbor.isVisited) {\n        // Update the neighbor's distance.\n        neighbor.distance = node.distance + weight;\n        neighbor.previousNode = node;\n        priorityQueue.insert(neighbor, targetNode);\n        neighbor.isVisited = true;\n      } else {\n        // Update neighbor's distance to minimum of possible routes to that neighbor.\n        if (node.distance + weight < neighbor.distance) {\n          neighbor.distance = node.distance + weight;\n          neighbor.previousNode = node;\n          // Insert the neighbor into the queue again.\n          priorityQueue.insert(neighbor, targetNode);\n        }\n      }\n    }\n  }\n  // The target node could not be reached.\n  return { visitedNodesInOrder, shortestPathReversed };\n}\n\n// G function for aStar that returns distance it took to get to specified node.\nfunction g(node) {\n  return node.distance;\n}\n\n// Heuristic function for aStar using Manhattan distance.\nfunction h(node, targetNode) {\n  const dx = Math.abs(targetNode.row - node.row);\n  const dy = Math.abs(targetNode.col - node.col);\n  return dx + dy;\n}\n\nfunction f(node, targetNode) {\n  return h(node, targetNode) + g(node);\n}\n\n// Used to put nodes in a priority queue based on f score (g + h). This priority queue does\n// not support reprioritizing. Instead, nodes in the queue with updated distances are inserted\n// into the queue a second time. This is okay because it won't really affect runtime.\nclass MinHeap {\n  constructor(targetNode) {\n    this.heap = [null];\n    this.targetNode = targetNode;\n  }\n\n  // Insert an element into the heap and fix the heap.\n  insert(node, targetNode) {\n    this.heap.push(node);\n    let currIndex = this.heap.length - 1;\n    let parentIndex = Math.floor(currIndex / 2);\n    while (\n      currIndex > 1 &&\n      f(node, targetNode) <= f(this.heap[parentIndex], targetNode)\n    ) {\n      [this.heap[parentIndex], this.heap[currIndex]] = [\n        this.heap[currIndex],\n        this.heap[parentIndex],\n      ];\n      currIndex = parentIndex;\n      parentIndex = Math.floor(currIndex / 2);\n    }\n  }\n\n  // Pop minimum element from the front of the heap and fix the heap.\n  pop() {\n    if (this.heap.length > 2) {\n      const head = this.heap[1];\n      const tail = this.heap.splice(this.heap.length - 1)[0];\n      this.heap[1] = tail;\n\n      let currIndex = 1;\n      let leftChildIndex = currIndex * 2;\n      let rightChildIndex = currIndex * 2 + 1;\n      // While there are two child nodes, swap currNode with minChild if minChild is smaller.\n      while (this.heap[leftChildIndex] && this.heap[rightChildIndex]) {\n        let minChild = this.heap[leftChildIndex];\n        let minIndex = leftChildIndex;\n        if (\n          f(this.heap[rightChildIndex], this.targetNode) <\n          f(minChild, this.targetNode)\n        ) {\n          minChild = this.heap[rightChildIndex];\n          minIndex = rightChildIndex;\n        }\n        if (\n          f(this.heap[currIndex], this.targetNode) >\n          f(minChild, this.targetNode)\n        ) {\n          [this.heap[currIndex], this.heap[minIndex]] = [\n            this.heap[minIndex],\n            this.heap[currIndex],\n          ];\n          currIndex = minIndex;\n        } else {\n          break;\n        }\n        leftChildIndex = currIndex * 2;\n        rightChildIndex = currIndex * 2 + 1;\n      }\n      // If there is one child node, swap it with currNode if currNode is smaller.\n      if (\n        this.heap[leftChildIndex] &&\n        f(this.heap[currIndex], this.targetNode) >\n          f(this.heap[leftChildIndex], this.targetNode)\n      ) {\n        [this.heap[currIndex], this.heap[leftChildIndex]] = [\n          this.heap[leftChildIndex],\n          this.heap[currIndex],\n        ];\n      } else if (\n        this.heap[rightChildIndex] &&\n        f(this.heap[currIndex], this.targetNode) >\n          f(this.heap[rightChildIndex], this.targetNode)\n      ) {\n        [this.heap[currIndex], this.heap[rightChildIndex]] = [\n          this.heap[rightChildIndex],\n          this.heap[currIndex],\n        ];\n      }\n      return head;\n    } else if (this.heap.length === 2) {\n      return this.heap.splice(1, 1)[0];\n    } else {\n      return null;\n    }\n  }\n\n  // Returns true if the minheap is empty.\n  isEmpty() {\n    if (this.heap.length < 2) {\n      return true;\n    }\n    return false;\n  }\n}\n","import React, { Component } from \"react\";\n\nimport Node from \"./Node/Node\";\nimport DropdownMenu from \"./Buttons/DropdownMenu/DropdownMenu\";\nimport NavigationBar from \"./NavigationBar/NavigationBar\";\nimport DrawToggle from \"./Buttons/DrawToggle/DrawToggle\";\nimport Slider from \"./Buttons/Slider/Slider\";\nimport { AlgorithmTitle } from \"./AlgorithmTitle/AlgorithmTitle\";\nimport \"./Buttons/Button Styles/VisualizeButton.css\";\nimport { dijkstra } from \"./Search Algorithms/Dijkstra\";\nimport { breadthFirstSearch } from \"./Search Algorithms/BreadthFirstSearch\";\nimport { depthFirstSearch } from \"./Search Algorithms/DepthFirstSearch\";\nimport { aStar } from \"./Search Algorithms/AStar\";\n\nimport \"./PathfindingVisualizer.css\";\n\nconst NUM_ROWS = Math.floor(getScreenHeight() / 30);\nconst NUM_COLS = Math.floor(getScreenWidth() / 30);\n\nconst START_NODE_ROW = 5;\nconst START_NODE_COL = 1;\nconst TARGET_NODE_ROW = NUM_ROWS - 2;\nconst TARGET_NODE_COL = NUM_COLS - 2;\n\nconst DIJKSTRA = \"Dijkstra\";\nconst BFS = \"BFS\";\nconst DFS = \"DFS\";\nconst ASTAR = \"A*\";\n\nconst WALLS = \"Walls\";\nconst WEIGHTS = \"Weights\";\n\nexport default class PathfindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      startNodeRow: START_NODE_ROW,\n      startNodeCol: START_NODE_COL,\n      targetNodeRow: TARGET_NODE_ROW,\n      targetNodeCol: TARGET_NODE_COL,\n      mouseDown: false,\n      algorithm: DIJKSTRA,\n      drawMode: WALLS,\n      movingStart: false,\n      movingTarget: false,\n      movingLaunchPad: false,\n      weightValue: 5,\n      launchPadRow: null,\n      launchPadCol: null,\n    };\n  }\n\n  componentDidMount() {\n    const grid = this.createInitialGrid();\n    document.body.onmouseup = this.handleOnMouseUp.bind(this);\n    document.body.onmouseleave = this.handleOnMouseUp.bind(this);\n    this.setState({ grid: grid });\n  }\n\n  render() {\n    const { grid } = this.state;\n    return (\n      <div>\n        <AlgorithmTitle algorithm={this.state.algorithm} />\n        <NavigationBar>\n          <DropdownMenu title={this.state.algorithm}>\n            <button onClick={() => this.setState({ algorithm: DIJKSTRA })}>\n              Dijkstra\n            </button>\n            <button onClick={() => this.setState({ algorithm: BFS })}>\n              BFS\n            </button>\n            <button onClick={() => this.setState({ algorithm: DFS })}>\n              DFS\n            </button>\n            <button onClick={() => this.setState({ algorithm: ASTAR })}>\n              A*\n            </button>\n          </DropdownMenu>\n          <button\n            id=\"visualize-button\"\n            onClick={() => this.visualize(this.state.algorithm)}\n          >\n            Go\n          </button>\n          <button onClick={this.clearPath.bind(this)}>Clear Path</button>\n          <button onClick={this.clearWalls.bind(this)}>Clear Walls</button>\n          <button\n            onClick={this.clearWeights.bind(this)}\n            style={{ marginRight: \"100px\" }}\n          >\n            Clear Weights\n          </button>\n          <DrawToggle\n            setDrawMode={(mode) => {\n              this.setState({ drawMode: mode });\n            }}\n          />\n          <Slider\n            value={this.state.weightValue}\n            setValue={this.setWeightValue.bind(this)}\n          />\n        </NavigationBar>\n\n        {this.displayGrid(grid)}\n        {/*<div className=\"credits\">\n          <a target=\"_blank\" href=\"https://icons8.com/icon/62234/launch\">\n            Launch\n          </a>{\" \"}\n          icon by{\" \"}\n          <a target=\"_blank\" href=\"https://icons8.com\">\n            Icons8\n          </a>\n          <a target=\"_blank\" href=\"https://icons8.com/icon/100900/empty-flag\">\n            Empty Flag\n          </a>{\" \"}\n          icon by{\" \"}\n          <a target=\"_blank\" href=\"https://icons8.com\">\n            Icons8\n          </a>\n          <a\n            target=\"_blank\"\n            href=\"https://icons8.com/icon/118838/vertical-line\"\n          >\n            Vertical Line\n          </a>{\" \"}\n          icon by{\" \"}\n          <a target=\"_blank\" href=\"https://icons8.com\">\n            Icons8\n          </a>\n          <div>\n            Icons made by{\" \"}\n            <a href=\"https://www.freepik.com\" title=\"Freepik\">\n              Freepik\n            </a>{\" \"}\n            from{\" \"}\n            <a href=\"https://www.flaticon.com/\" title=\"Flaticon\">\n              www.flaticon.com\n            </a>\n          </div>\n    </div>\n    <div>Icons made by <a href=\"\" title=\"Vitaly Gorbachev\">Vitaly Gorbachev</a> from <a href=\"https://www.flaticon.com/\" title=\"Flaticon\">www.flaticon.com</a></div>*/}\n      </div>\n    );\n  }\n\n  setWeightValue(value) {\n    this.setState({ weightValue: value });\n  }\n\n  visualize(algorithm) {\n    switch (algorithm) {\n      case DIJKSTRA:\n        this.visualizeDijkstra();\n        break;\n      case BFS:\n        this.visualizeBreadthFirstSearch();\n        break;\n      case DFS:\n        this.visualizeDepthFirstSearch();\n        break;\n      case ASTAR:\n        this.visualizeAStar();\n        break;\n      default:\n        return;\n    }\n  }\n\n  // Used to disply disjkstra when moving launch pad,\n  // instead of fully animating dijkstra.\n  redrawPath() {\n    let grid = this.copyGrid();\n    const startNode = grid[this.state.launchPadRow][this.state.launchPadCol];\n    const targetNode = grid[this.state.targetNodeRow][this.state.targetNodeCol];\n\n    var pathReversed;\n\n    switch (this.state.algorithm) {\n      case DIJKSTRA:\n        pathReversed = dijkstra(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS,\n          this.state.weightValue\n        ).shortestPathReversed;\n        break;\n      case BFS:\n        pathReversed = breadthFirstSearch(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS\n        ).shortestPathReversed;\n        break;\n      case DFS:\n        pathReversed = depthFirstSearch(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS\n        ).pathReversed;\n        break;\n      case ASTAR:\n        pathReversed = aStar(\n          grid,\n          startNode,\n          targetNode,\n          NUM_ROWS,\n          NUM_COLS,\n          this.state.weightValue\n        ).shortestPathReversed;\n        break;\n      default:\n        return;\n    }\n\n    /*const { shortestPathReversed } = dijkstra(\n      grid,\n      startNode,\n      targetNode,\n      NUM_ROWS,\n      NUM_COLS,\n      this.state.weightValue\n    );*/\n\n    const lines = this.pathToLines(pathReversed);\n\n    grid = this.copyGrid();\n\n    for (let i = 0; i < pathReversed.length; i++) {\n      const row = pathReversed[i].row;\n      const col = pathReversed[i].col;\n      grid[row][col].direction = lines[i];\n      grid[row][col].isPath = true;\n    }\n    this.setState({ grid: grid });\n  }\n\n  visualizeDijkstra() {\n    let grid = this.copyGrid();\n    this.resetNodes(grid);\n    this.setState({ grid: grid }, () => {\n      grid = this.copyGrid();\n      const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\n      const targetNode =\n        grid[this.state.targetNodeRow][this.state.targetNodeCol];\n      const { visitedNodesInOrder, shortestPathReversed } = dijkstra(\n        grid,\n        startNode,\n        targetNode,\n        NUM_ROWS,\n        NUM_COLS,\n        this.state.weightValue\n      );\n      this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n    });\n  }\n\n  visualizeBreadthFirstSearch() {\n    let grid = this.copyGrid();\n    this.resetNodes(grid);\n    this.setState({ grid: grid }, () => {\n      grid = this.copyGrid();\n      const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\n      const targetNode =\n        grid[this.state.targetNodeRow][this.state.targetNodeCol];\n      const { visitedNodesInOrder, shortestPathReversed } = breadthFirstSearch(\n        grid,\n        startNode,\n        targetNode,\n        NUM_ROWS,\n        NUM_COLS\n      );\n      this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n    });\n  }\n\n  visualizeDepthFirstSearch() {\n    let grid = this.copyGrid();\n    this.resetNodes(grid);\n    this.setState({ grid: grid }, () => {\n      grid = this.copyGrid();\n      const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\n      const targetNode =\n        grid[this.state.targetNodeRow][this.state.targetNodeCol];\n      const { visitedNodesInOrder, pathReversed } = depthFirstSearch(\n        grid,\n        startNode,\n        targetNode,\n        NUM_ROWS,\n        NUM_COLS\n      );\n      this.animateSearch(visitedNodesInOrder, pathReversed);\n    });\n  }\n\n  visualizeAStar() {\n    let grid = this.copyGrid();\n    this.resetNodes(grid);\n    this.setState({ grid: grid }, () => {\n      grid = this.copyGrid();\n      const startNode = grid[this.state.startNodeRow][this.state.startNodeCol];\n      const targetNode =\n        grid[this.state.targetNodeRow][this.state.targetNodeCol];\n      const { visitedNodesInOrder, shortestPathReversed } = aStar(\n        grid,\n        startNode,\n        targetNode,\n        NUM_ROWS,\n        NUM_COLS,\n        this.state.weightValue\n      );\n      this.animateSearch(visitedNodesInOrder, shortestPathReversed);\n    });\n  }\n\n  animateSearch(visitedNodesInOrder, pathReversed) {\n    for (let i = 0; i < visitedNodesInOrder.length; i++) {\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // Start path animation after last visited node.\n        if (i === visitedNodesInOrder.length - 1) {\n          this.animatePath(pathReversed);\n        } else {\n          if (!node.isStart && !node.isTarget) {\n            // Normally shouldn't do this, but had to to optimize performance.\n            const element = document.getElementById(\n              `node-${node.row}-${node.col}`\n            );\n            element.classList.remove(\"unvisited\");\n            element.classList.add(\"visited\");\n          }\n        }\n      }, 5 * i);\n    }\n  }\n\n  animatePath(pathReversed) {\n    const lines = this.pathToLines(pathReversed);\n    let startRow = this.state.startNodeRow;\n    let startCol = this.state.startNodeCol;\n    for (let i = pathReversed.length - 1; i >= 0; i--) {\n      startRow = pathReversed[i].row;\n      startCol = pathReversed[i].col;\n      setTimeout(\n        () => this.moveRocketShip(pathReversed, lines, i),\n        3000 * ((pathReversed.length - i) / pathReversed.length)\n      );\n    }\n  }\n\n  moveRocketShip(pathReversed, lines, i) {\n    const node = pathReversed[i];\n    if (!node.isStart) {\n      const prevNode = pathReversed[i + 1];\n      const grid = this.copyGrid();\n      grid[prevNode.row][prevNode.col].isStart = false;\n      grid[prevNode.row][prevNode.col].isPath = true;\n      grid[prevNode.row][prevNode.col].direction = lines[i + 1];\n      grid[node.row][node.col].isStart = true;\n      if (grid[node.row][node.col].isTarget) {\n        grid[node.row][node.col].isTargetReached = true;\n      }\n      if (grid[prevNode.row][prevNode.col].direction === \"landing-pad\") {\n        this.setState({\n          grid: grid,\n          launchPadRow: prevNode.row,\n          launchPadCol: prevNode.col,\n        });\n        return;\n      }\n      this.setState({ grid: grid });\n    }\n  }\n\n  // Returns an array of lines, given a path of nodes.\n  pathToLines(pathReversed) {\n    const lines = [];\n    const directions = [];\n    directions.push(\"none\");\n    for (let i = 1; i < pathReversed.length; i++) {\n      let prevNode = pathReversed[i - 1];\n      let currNode = pathReversed[i];\n      let dRow = prevNode.row - currNode.row;\n      let dCol = currNode.col - prevNode.col;\n      const direction =\n        dCol === 1\n          ? \"right\"\n          : dCol === -1\n          ? \"left\"\n          : dRow === 1\n          ? \"up\"\n          : dRow === -1\n          ? \"down\"\n          : \"\";\n      directions.push(direction);\n      const line =\n        direction === \"right\" && directions[i - 1] === \"none\"\n          ? \"horizontal\"\n          : direction === \"right\" && directions[i - 1] === \"right\"\n          ? \"horizontal\"\n          : direction === \"right\" && directions[i - 1] === \"up\"\n          ? \"ul\"\n          : direction === \"right\" && directions[i - 1] === \"down\"\n          ? \"bl\"\n          : direction === \"left\" && directions[i - 1] === \"none\"\n          ? \"horizontal\"\n          : direction === \"left\" && directions[i - 1] === \"left\"\n          ? \"horizontal\"\n          : direction === \"left\" && directions[i - 1] === \"up\"\n          ? \"ur\"\n          : direction === \"left\" && directions[i - 1] === \"down\"\n          ? \"br\"\n          : direction === \"up\" && directions[i - 1] === \"none\"\n          ? \"vertical\"\n          : direction === \"up\" && directions[i - 1] === \"up\"\n          ? \"vertical\"\n          : direction === \"up\" && directions[i - 1] === \"left\"\n          ? \"bl\"\n          : direction === \"up\" && directions[i - 1] === \"right\"\n          ? \"br\"\n          : direction === \"down\" && directions[i - 1] === \"none\"\n          ? \"vertical\"\n          : direction === \"down\" && directions[i - 1] === \"down\"\n          ? \"vertical\"\n          : direction === \"down\" && directions[i - 1] === \"left\"\n          ? \"ul\"\n          : direction === \"down\" && directions[i - 1] === \"right\"\n          ? \"ur\"\n          : \"\";\n      lines.push(line);\n    }\n    lines.push(\"landing-pad\");\n    return lines;\n  }\n\n  // Handles onMouseDown event on node at given row and column.\n  handleOnMouseDown(row, col) {\n    const grid = this.copyGrid();\n    const node = grid[row][col];\n    // Start moving target node.\n    if (node.isTarget) {\n      this.setState({ movingTarget: true, mouseDown: true });\n      return;\n    }\n    // Start moving launch pad.\n    if (node.isPath && node.direction === \"landing-pad\") {\n      this.setState({ movingLaunchPad: true, mouseDown: true });\n      return;\n    }\n    // Start moving start node.\n    if (node.isStart) {\n      this.setState({ movingStart: true, mouseDown: true });\n      return;\n    }\n    // Start drawing walls or weights no the node.\n    switch (this.state.drawMode) {\n      case WALLS:\n        node.isWall = !node.isWall;\n        node.isWeight = false;\n        this.setState({ grid: grid, mouseDown: true });\n        break;\n      case WEIGHTS:\n        node.isWeight = !node.isWeight;\n        node.isWall = false;\n        this.setState({ grid: grid, mouseDown: true });\n        break;\n      default:\n        return;\n    }\n  }\n\n  handleOnMouseUp() {\n    if (this.state.mouseDown === true) {\n      this.setState({\n        mouseDown: false,\n        movingStart: false,\n        movingTarget: false,\n        movingLaunchPad: false,\n      });\n    }\n  }\n\n  handleOnMouseEnter(row, col) {\n    if (this.state.mouseDown === true) {\n      const grid = this.copyGrid();\n      const node = grid[row][col];\n      // Move target node.\n      if (this.state.movingTarget) {\n        // Remove path.\n        for (const row of grid) {\n          for (var node_ of row) {\n            node_.isPath = false;\n            node_.direction = null;\n            node_.isVisited = false;\n          }\n        }\n        // Move target node.\n        const prevTarget =\n          grid[this.state.targetNodeRow][this.state.targetNodeCol];\n        if (!prevTarget.isTargetReached) {\n          // Target was never reached, no need to redraw.\n          prevTarget.isTarget = false;\n          node.isTarget = true;\n          this.setState({ grid: grid, targetNodeRow: row, targetNodeCol: col });\n          return;\n        }\n        prevTarget.isTarget = false;\n        prevTarget.isTargetReached = false;\n        prevTarget.isStart = false;\n        node.isTarget = true;\n        node.isTargetReached = true;\n        // Set state.\n        this.setState(\n          {\n            grid: grid,\n            targetNodeRow: row,\n            targetNodeCol: col,\n          },\n          // ReDraw path.\n          this.redrawPath\n        );\n        return;\n        /*this.setState({ grid: grid, targetNodeRow: row, targetNodeCol: col });\n        return;*/\n      }\n      // Move launch pad.\n      if (this.state.movingLaunchPad) {\n        // Remove path.\n        for (const row of grid) {\n          for (var node_ of row) {\n            node_.isPath = false;\n            node_.direction = null;\n            node_.isVisited = false;\n          }\n        }\n        // Move launch pad.\n        const prevLaunchPad =\n          grid[this.state.launchPadRow][this.state.launchPadCol];\n        prevLaunchPad.isPath = false;\n        prevLaunchPad.direction = null;\n        node.isPath = true;\n        node.direction = \"landing-pad\";\n        // Adjust start node.\n        const prevStart =\n          grid[this.state.startNodeRow][this.state.startNodeCol];\n        prevStart.isStart = false;\n        node.isStart = true;\n        // Set state.\n        this.setState(\n          {\n            grid: grid,\n            launchPadRow: row,\n            launchPadCol: col,\n            startNodeRow: row,\n            startNodeCol: col,\n          },\n          // ReDraw path.\n          this.redrawPath\n        );\n        return;\n      }\n      // Move start node.\n      if (this.state.movingStart) {\n        const prevStart =\n          grid[this.state.startNodeRow][this.state.startNodeCol];\n        prevStart.isStart = false;\n        node.isStart = true;\n        this.setState({ grid: grid, startNodeRow: row, startNodeCol: col });\n        return;\n      }\n\n      switch (this.state.drawMode) {\n        case WALLS:\n          node.isWall = !node.isWall;\n          node.isWeight = false;\n          this.setState({ grid: grid });\n          break;\n        case WEIGHTS:\n          node.isWeight = !node.isWeight;\n          node.isWall = false;\n          this.setState({ grid: grid });\n          break;\n        default:\n          return;\n      }\n    }\n  }\n\n  // Create a 2D array of node objects.\n  createInitialGrid() {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLS; col++) {\n        const currNode = new NodeObj(col, row);\n        if (\n          row === this.state.startNodeRow &&\n          col === this.state.startNodeCol\n        ) {\n          currNode.isStart = true;\n        } else if (\n          row === this.state.targetNodeRow &&\n          col === this.state.targetNodeCol\n        ) {\n          currNode.isTarget = true;\n        }\n        currentRow.push(currNode);\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }\n\n  // Map the grid to Node components that are displayed.\n  displayGrid(nodes) {\n    return (\n      <div className=\"grid\">\n        {nodes.map((row, rowIndex) => {\n          return (\n            <div className=\"row\" key={rowIndex}>\n              {row.map((node, nodeIndex) => {\n                return (\n                  <Node\n                    draggable=\"false\"\n                    key={nodeIndex}\n                    isStart={node.isStart}\n                    isTarget={node.isTarget}\n                    isWall={node.isWall}\n                    isWeight={node.isWeight}\n                    isVisited={node.isVisited}\n                    isPath={node.isPath}\n                    row={node.row}\n                    col={node.col}\n                    direction={node.direction}\n                    isTargetReached={node.isTargetReached}\n                    handleOnMouseDown={this.handleOnMouseDown.bind(this)}\n                    handleOnMouseUp={this.handleOnMouseUp.bind(this)}\n                    handleOnMouseEnter={this.handleOnMouseEnter.bind(this)}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n\n  resetNodes(grid) {\n    for (const row of grid) {\n      for (const node of row) {\n        // We have to reset isVisited, and isPath of nodes the same way we set them.\n        if (!node.isWall && !node.isStart && !node.isTarget && !node.isWeight) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node\";\n        } else if (node.isWeight) {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            \"node node-weight unvisited\";\n        }\n        node.isVisited = false;\n        node.isPath = false;\n        node.previousNode = null;\n        node.distance = Infinity;\n        node.isStart =\n          node.row === this.state.startNodeRow &&\n          node.col === this.state.startNodeCol;\n        node.isTarget =\n          node.row === this.state.targetNodeRow &&\n          node.col === this.state.targetNodeCol;\n        node.isTargetReached = false;\n      }\n    }\n  }\n\n  clearPath() {\n    const grid = this.copyGrid();\n    this.resetNodes(grid);\n    this.setState({ grid: grid });\n  }\n\n  clearWalls() {\n    const grid = this.copyGrid();\n    for (const row of grid) {\n      for (const node of row) {\n        if (node.isWall) {\n          node.isWall = false;\n        }\n      }\n    }\n    this.setState({ grid: grid });\n  }\n\n  clearWeights() {\n    const grid = this.copyGrid();\n    for (const row of grid) {\n      for (const node of row) {\n        if (node.isWeight) {\n          node.isWeight = false;\n        }\n      }\n    }\n    this.setState({ grid: grid });\n  }\n\n  copyGrid() {\n    const grid = this.state.grid;\n    const copiedGrid = [];\n    for (const row of grid) {\n      const copiedRow = row.map((node) => {\n        const copiedNode = Object.assign({}, node);\n        return copiedNode;\n      });\n      copiedGrid.push(copiedRow);\n    }\n    return copiedGrid;\n  }\n}\n\n// Node object constructor.\nfunction NodeObj(col, row) {\n  this.col = col;\n  this.row = row;\n  this.isStart = false;\n  this.isTarget = false;\n  this.isVisited = false;\n  this.isWall = false;\n  this.isWeight = false;\n  // Distance from start node.\n  this.distance = Infinity;\n  // Previous node used to trace path.\n  this.previousNode = null;\n  this.direction = null;\n  this.isTargetReached = false;\n}\n\n// Function to get the width of the browser window.\nfunction getScreenWidth() {\n  return Math.max(\n    document.body.scrollWidth,\n    document.documentElement.scrollWidth,\n    document.body.offsetWidth,\n    document.documentElement.offsetWidth,\n    document.documentElement.clientWidth\n  );\n}\n\nfunction getScreenHeight() {\n  return window.innerHeight;\n}\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n        <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}